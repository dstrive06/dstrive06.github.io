<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第11章 后端编译与优化 | dstrive</title><meta name="keywords" content="blog"><meta name="author" content="dstrive"><meta name="copyright" content="dstrive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="11.1 概述如果我们把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话，那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。 无论是提前编译器抑或即时编译器，都不是Java虚拟机必需的组成部分，《Java虚拟机规范》中从来没有规定过虚拟机内部必须要">
<meta property="og:type" content="article">
<meta property="og:title" content="第11章 后端编译与优化">
<meta property="og:url" content="https://dstrive06.github.io/blog/8c72b87b40d9/index.html">
<meta property="og:site_name" content="dstrive">
<meta property="og:description" content="11.1 概述如果我们把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话，那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。 无论是提前编译器抑或即时编译器，都不是Java虚拟机必需的组成部分，《Java虚拟机规范》中从来没有规定过虚拟机内部必须要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg">
<meta property="article:published_time" content="2022-05-18T12:57:36.000Z">
<meta property="article:modified_time" content="2022-05-18T12:57:36.000Z">
<meta property="article:author" content="dstrive">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dstrive06.github.io/blog/8c72b87b40d9/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: dstrive","link":"链接: ","source":"来源: dstrive","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第11章 后端编译与优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-05-18 20:57:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">dstrive</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第11章 后端编译与优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-18T12:57:36.000Z" title="发表于 2022-05-18 20:57:36">2022-05-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-18T12:57:36.000Z" title="更新于 2022-05-18 20:57:36">2022-05-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/">《深入理解Java虚拟机》</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/">第十一章</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第11章 后端编译与优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><p>如果我们把<strong>字节码</strong>看作是程序语言的一种<strong>中间表示形式（Intermediate Representation，IR）</strong>的话，那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。</p>
<p>无论是<strong>提前编译器</strong>抑或<strong>即时编译器</strong>，都不是Java虚拟机必需的组成部分，《Java虚拟机规范》中从来没有规定过虚拟机内部必须要包含这些编译器，更没有限定或指导这些编译器应该如何去实现。</p>
<p>但是，<strong>后端编译器编译性能的好坏、代码优化质量的高低却是衡量一款商用虚拟机优秀与否的关键指标之一</strong>，它们也是商业Java虚拟机中的核心，是最能体现技术水平与价值的功能。</p>
<h2 id="11-2-即时编译器"><a href="#11-2-即时编译器" class="headerlink" title="11.2 即时编译器"></a>11.2 即时编译器</h2><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过<strong>解释器（Interpreter）</strong>进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为<strong>“热点代码”（Hot Spot Code）</strong>，<strong>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化</strong>，运行时完成这个任务的后端编译器被称 为**<u>即时编译器</u>**。</p>
<ul>
<li>为何HotSpot虚拟机要使用<strong>解释器与即时编译器并存的架构</strong>？</li>
<li>为何HotSpot虚拟机要<strong>实现两个（或三个）不同的即时编译器</strong>？ </li>
<li>程序<strong>何时使用解释器</strong>执行？<strong>何时使用编译器</strong>执行？ </li>
<li>哪些程序代码会被编译为<strong>本地代码</strong>？如何编译本地代码？</li>
<li>如何从外部观察到即时编译器的编译过程和编译结果？</li>
</ul>
<h3 id="11-2-1-解释器与编译器"><a href="#11-2-1-解释器与编译器" class="headerlink" title="11.2.1 解释器与编译器"></a>11.2.1 解释器与编译器</h3><p>目前主流的商用Java虚拟机，譬如HotSpot、OpenJ9等，内部都<strong>同时包含解释器与编译器</strong>，解释器与编译器两者各有优势：</p>
<ul>
<li><p>当程序需要<strong>迅速启动和执行</strong>的时候，<strong>解释器</strong>可以首先发挥作用，省去编译的时间，立即运行。</p>
</li>
<li><p>当程序<strong>启动后</strong>，随着时间的推移，<strong>编译器逐渐发挥作用</strong>，<strong>把越来越多的代码编译成本地代码</strong>，这样可以<strong>减少解释器的中间损耗</strong>，获得更高的执行效率。</p>
</li>
<li><p>当<strong>程序运行环境中内存资源限制较大</strong>，可以<strong>使用解释执行节约内存</strong>（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），<strong>反之可以使用编译执行来提升效率</strong>。</p>
</li>
</ul>
<p>同时，**<u>解释器</u>还可以作为编译器激进优化时后备的“逃生门”**（如果情况允许，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行，因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作，其交互关系如图11-1所示。 </p>
<p><img src="interperter-with-compiler.png" alt="image-20220507073230239"></p>
<center>图11-1 解释器与编译器的交互</center>

<p><strong>HotSpot虚拟机中内置了两个（或三个）即时编译器</strong>，其中有两个编译器存在已久，分别被称为<strong>“客户端编译器”（Client Compiler）</strong>和<strong>“服务端编译器”（Server Compiler）</strong>，或者简称为<strong>C1编译器和C2编译器</strong>（部分资料和JDK源码中C2也叫Opto编译器），第三个是在JDK 10时才出现的、长期目标是代替C2的<strong>Graal编译器</strong>。</p>
<p>在分层编译（Tiered Compilation）的工作模式出现以前，HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作，程序使用哪个编译器，只取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在客户端模式还是服务端模式。</p>
<p>无论采用的编译器是<strong>客户端编译器</strong>还是<strong>服务端编译器</strong>，<strong>解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”（Mixed Mode）</strong>，用户也可以使用<strong>参数“-Xint”</strong>强制虚拟机运行于<strong>“解释模式”（Interpreted Mode）</strong>，这时候编译器完全不介入工作，全部代码都使用解释方式执行。</p>
<p>另外，也可以使用<strong>参数“-Xcomp”</strong>强制虚拟机运行于<strong>“编译模式”（Compiled Mode）</strong>，这时候将<strong>优先采用编译方式执行程序</strong>，<strong>但是解释器仍然要在编译无法进行的情况下介入执行过程</strong>。可以通过虚拟机的“-version”命令的输出结果显示出这三种模式，内容如代码清单11-1所示。</p>
<p>代码清单11-1 虚拟机执行模式 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Dstrive&gt;java -Xint -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_181&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_181</span>-b13)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.181</span>-b13, interpreted mode)</span></span><br><span class="line"></span><br><span class="line">C:\Users\Dstrive&gt;java -Xcomp -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_181&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_181</span>-b13)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.181</span>-b13, compiled mode)</span></span><br><span class="line"></span><br><span class="line">C:\Users\Dstrive&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_181&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_181</span>-b13)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.181</span>-b13, mixed mode)</span></span><br></pre></td></tr></table></figure>

<p>由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长；</p>
<p><strong>而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。</strong></p>
<p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了<strong>分层编译</strong>的功能。</p>
<p>分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ul>
<li>第0层。<ul>
<li>程序<strong>纯解释执行</strong>，并且<strong>解释器不开启性能监控功能（Profiling）</strong>。</li>
</ul>
</li>
<li>第1层。<ul>
<li>使用<strong>客户端编译器将字节码编译为本地代码来运行</strong>，进行简单可靠的稳定优化，<strong>不开启性能监控功能</strong>。</li>
</ul>
</li>
<li>第2层。<ul>
<li>仍然使用客<strong>户端编译器执行</strong>，<strong>仅开启方法及回边次数统计等有限的性能监控功能</strong>。 </li>
</ul>
</li>
<li>第3层。<ul>
<li>仍然使用<strong>客户端编译器执行</strong>，<strong>开启全部性能监控</strong>，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。 </li>
</ul>
</li>
<li>第4层。<ul>
<li>使用<strong>服务端编译器将字节码编译为本地代码</strong>，相比起客户端编译器，<strong>服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化</strong>。 </li>
</ul>
</li>
</ul>
<p>以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。各层次编译之间的交互、转换关系如图11-2<a href="%E5%9B%BE%E7%89%87%E6%9D%A5%E6%BA%90%EF%BC%9Ahttps://www.infoq.cn/article/java-10-jit-compiler-graal/%E3%80%82">^1</a>所示。</p>
<p><img src="hierarchical-compiler.png" alt="image-20220507075113214"></p>
<center>图11-2 分层编译的交互关系</center>



<h3 id="11-2-2-编译对象与触发条件"><a href="#11-2-2-编译对象与触发条件" class="headerlink" title="11.2.2 编译对象与触发条件"></a>11.2.2 编译对象与触发条件</h3><p>在运行过程中会被即时编译器编译的目标是“热点代码”，这里所指的热点代码主要有两类，包括： </p>
<ul>
<li>被多次调用的方法。<ul>
<li>一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为“热点代码”是理所当然的。</li>
</ul>
</li>
<li>被多次执行的循环体。<ul>
<li>后者则是为了解决当一个方法只被调用过一次或少量的几次，但是<strong>方法体内部存在循环次数较多的循环体</strong>，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”。</li>
</ul>
</li>
</ul>
<p>对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。</p>
<p>第一种情况，由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式。</p>
<p>而对于后一种情况，尽管<strong>编译动作是由循环体所触发</strong>的，<strong>热点只是方法的一部分</strong>，但<strong>编译器依然必须以整个方法作为编译对象</strong>，只是<strong>执行入口</strong>（从方法第几条字节码指令开始执行）会稍有不同，<strong>编译时会传入执行入口点字节码序号（Byte Code Index，BCI）</strong>。</p>
<ul>
<li>这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为<strong>“栈上替换”（On Stack Replacement，OSR）</strong>，即<strong>方法的栈帧还在栈上，方法就被替换了</strong>。</li>
</ul>
<p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为<strong>“热点探测”（HotSpot Code Detection）</strong>，其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主流的热点探测判定方式有两种，分别是：</p>
<ul>
<li><p><strong>基于采样的热点探测（Sample Based Hot Spot Code Detection）：</strong></p>
<ul>
<li>采用这种方法的虚拟机会<strong>周期性地检查各个线程的调用栈顶</strong>，如果<strong>发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”</strong>。</li>
<li>基于采样的热点探测的<strong>好处是实现简单高效</strong>，还可以<strong>很容易地获取方法调用关系</strong>（将调用堆栈展开即可），<strong>缺点是很难精确地确认一个方法的热度</strong>，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
</ul>
</li>
<li><p><strong>基于计数器的热点探测（Counter Based Hot Spot Code Detection）：</strong></p>
<ul>
<li>采用这种方法的虚拟机会<strong>为每个方法（甚至是代码块）建立<u>计数器</u><strong>，统计方法的执行次数，如果</strong>执行次数超过一定的阈值就认为它是“热点方法”</strong>。</li>
<li><strong>这种统计方法实现起来要麻烦一些</strong>，需要<strong>为每个方法建立并维护计数器</strong>，而且<strong>不能直接获取到方法的调用关系</strong>。但是它的<strong>统计结果相对来说更加精确严谨</strong>。 </li>
</ul>
</li>
</ul>
<p>s</p>
<p>这两种探测手段在商用Java虚拟机中都有使用到，譬如<strong>J9用过第一种采样热点探测</strong>，而在<strong>HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法</strong>，为了实现热点计数，HotSpot为每个方法准备了两类计数器：</p>
<ul>
<li><strong>方法调用计数器（Invocation Counter）</strong>和</li>
<li><strong>回边计数器（Back Edge Counter，“回边”的意思就是指在循环边界往回跳转）</strong>。</li>
</ul>
<p>当虚拟机运行参数确定的前提下，<strong>这两个计数器都有一个明确的阈值</strong>，计数器阈值一旦溢出，就会触发即时编译。 </p>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>顾名思义，这个计数器就是用于统计方法被调用的次数，它的<strong>默认阈值在客户端模式下是1500次</strong>，在<strong>服务端模式下是10000次</strong>，这个阈值可以通过<strong>虚拟机参数-XX：CompileThreshold</strong>来人为设定。</p>
<ul>
<li>当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后<strong>判断<u>方法调用计数器与回边计数器值之和</u>是否超过方法调用计数器的阈值</strong>。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。 </li>
</ul>
<p>如果没有做过任何设置，<strong>执行引擎默认不会同步等待编译请求完成</strong>，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成。</p>
<p><strong>当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值，下一次调用该方法时就会使用已编译的版本了</strong>，整个即时编译的交互过程如图11-3所示。</p>
<p><img src="compiler-with-counter.png" alt="image-20220508123101651"></p>
<center>图11-3 方法调用计数器触发即时编译 </center>



<p>在默认设置下，<strong>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个<u>相对的执行频率</u><strong>，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为</strong>方法调用计数器热度的衰减（Counter Decay）</strong>，而这段时间就称为此<strong>方法统计的半衰周期（Counter Half Life Time）</strong>，进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机<strong>参数-XX：-UseCounterDecay</strong>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外还可以使用**-XX：CounterHalfLifeTime参数**设置半衰周期的时间，单位是秒。</p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数[^2]，在<strong>字节码</strong>中遇到控制流向后跳转的指令就称为<strong>“回边（Back Edge）”</strong>，很显然建立回边计数器统计的目的是<strong>为了触发栈上的替换编译。</strong></p>
<p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。</p>
<p>当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果，整个执行过程如图11-4所示。</p>
<p><img src="compiler-with-boundary-of-back.png" alt="image-20220508130008131"></p>
<center>图11-4 回边计数器触发即时编译 </center>

<p>与方法计数器不同，<strong>回边计数器没有计数热度衰减的过程</strong>，<strong>因此这个计数器统计的就是该方法循环执行的绝对次数</strong>。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。 </p>
<p>[^2]: 准确地说，应当是回边的次数而不是循环次数，因为并非所有的循环都是回边，如空循环实际上就 可以视为自己跳转到自己的过程，因此并不算作控制流向后跳转，也不会被回边计数器统计。</p>
<h3 id="11-2-3-编译过程"><a href="#11-2-3-编译过程" class="headerlink" title="11.2.3 编译过程"></a>11.2.3 编译过程</h3><p>在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，<strong>虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行</strong>。 </p>
<p>用户可以通过<strong>参数-XX：-BackgroundCompilation</strong>来禁止后台编译，后台编译被禁止后，当达到触发即时编译的条件时，执行线程向虚拟机提交编译请求以后将会一直阻塞等待，直到编译过程完成再开始执行编译器输出的本地代码。 </p>
<p>那在后台执行编译的过程中，编译器具体会做什么事情呢？</p>
<ul>
<li><strong>服务端编译器和客户端编译器的编译过程是有所差别的。</strong></li>
<li>对于客户端编译器来说，它是一个相对简单快速的<strong>三段式编译器</strong>，<strong>主要的关注点在于局部性的优化</strong>，而放弃了许多耗时较长的全局优化手段。 </li>
</ul>
<h4 id="后端编译—客户端"><a href="#后端编译—客户端" class="headerlink" title="后端编译—客户端"></a>后端编译—客户端</h4><h5 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h5><p>一个<strong>平台独立的前端</strong>将字节码构造成一种<strong>高级中间代码表示（High-Level Intermediate Representation，HIR，即与目标机器指令集无关的中间表示）</strong>。</p>
<p><strong>HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值</strong>，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。<strong>在此之前编译器已经会在字节码上完成一部分基础优化</strong>，如**<u>方法内联、 常量传播</u>等优化将会在字节码被构造成HIR之前完成**。</p>
<h5 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h5><p>一个<strong>平台相关的后端</strong>从HIR中产生<strong>低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示）</strong>，而在此之前会在HIR上完成另外一些优化，如**<u>空值检查消除、范围检查消除</u>**等，以便让HIR达到更高效的代码表示形式。</p>
<h4 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h4><p>是在<strong>平台相关的后端</strong>使用<strong>线性扫描算法（Linear Scan Register Allocation）</strong>在LIR上分配寄存器，并在LIR上做<strong>窥孔（Peephole）优化</strong>，然后<strong>产生机器代码</strong>。</p>
<p>客户端编译器大致的执行过程如图11-5所示。</p>
<p><img src="client-compiler.png" alt="image-20220508143048469"></p>
<center>图11-5 Client Compiler架构 </center>



<h4 id="后端编译—服务端"><a href="#后端编译—服务端" class="headerlink" title="后端编译—服务端"></a>后端编译—服务端</h4><p><strong>服务端编译器则是专门面向服务端的典型应用场景</strong>，并为服务端的性能配置针对性调整过的编译器，<strong>也是一个能容忍很高优化复杂度的高级编译器</strong>，几乎能达到GNU C++编译器使用-O2参数时的优化强度。</p>
<p>它会执行<strong>大部分经典的优化动作</strong>，如：</p>
<ul>
<li><strong>无用代码消除（Dead Code Elimination）</strong>、</li>
<li><strong>循环展开（Loop Unrolling）</strong>、</li>
<li><strong>循环表达式外提（Loop Expression Hoisting）</strong>、</li>
<li><strong>消除公共子表达式（Common Subexpression Elimination）</strong>、</li>
<li><strong>常量传播（Constant Propagation）</strong>、</li>
<li><strong>基本块重排序（Basic Block Reordering）</strong>等，</li>
</ul>
<p>还会实施一些<strong>与Java语言特性密切相关的优化技术</strong>，如</p>
<ul>
<li><strong>范围检查消除（Range Check Elimination）</strong>、</li>
<li><strong>空值检查消除（Null Check Elimination，不过并非所有的空值检查消除都是依赖编译器优化的，有一些是代码运行过程中自动优化了）</strong>等。</li>
</ul>
<p>另外，还可能<strong>根据解释器或客户端编译器提供的性能监控信息</strong>，进行一些<strong>不稳定的预测性激进优化</strong>，如</p>
<ul>
<li><strong>守护内联（Guarded Inlining）</strong>、</li>
<li><strong>分支频率预测 （Branch Frequency Prediction）</strong>等</li>
</ul>
<p>**服务端编译采用的寄存器分配器是一个<u>全局图着色分配器</u>**，它可以充分利用某些处理器架构（如RISC）上的大寄存器集合。</p>
<p>以即时编译的标准来看，服务端编译器无疑是比较缓慢的，<strong>但它的编译速度依然远远超过传统的静态优化编译器</strong>，而且<strong>它相对于客户端编译器编译输出的代码质量有很大提高</strong>，可以大幅减少本地代码的执行时间，从而抵消掉额外的编译时间开销，所以也有很多非服务端的应用选择使用服务端模式的HotSpot虚拟机来运行。 </p>
<h3 id="11-2-4-实战：查看及分析即时编译结果"><a href="#11-2-4-实战：查看及分析即时编译结果" class="headerlink" title="11.2.4 实战：查看及分析即时编译结果"></a>11.2.4 实战：查看及分析即时编译结果</h3><p>空循环会被编译器最终优化掉。</p>
<h2 id="11-3-提前编译器"><a href="#11-3-提前编译器" class="headerlink" title="11.3 提前编译器"></a>11.3 提前编译器</h2><p>在某些领域、某些人眼里，<strong>只要能获得更好的执行性能</strong>，什么平台中立性、字节膨胀（指提前编译的本地二进制码的体积会明显大于字节码的体积）、动态扩展（指提前编译通常要求程序是封闭的，不能在外部动态加载新的字节码。），一切皆可舍弃唯一的问题就只有“提前编译真的会是获得更高性能的银弹吗？” </p>
<p>现在提前编译产品和对其的研究有着两条明显的分支：</p>
<ul>
<li><p>一条分支是<strong>做与传统C、C++编译器类似的</strong>，<strong>在程序运行之前把程序代码编译成机器码的静态翻译工作</strong>；</p>
</li>
<li><p>另外一条分支是<strong>把原本即时编译器在运行时要做的编译工作提前做好并保存下来</strong>，<strong>下次运行到这些代码</strong>（譬如公共库代码在被同一台机器其他Java进程使用）<strong>时直接把它加载进来使用</strong>。 </p>
</li>
</ul>
<h4 id="提前编译的第一条路径"><a href="#提前编译的第一条路径" class="headerlink" title="提前编译的第一条路径"></a>提前编译的第一条路径</h4><p>在编译过程中最耗时的优化措施之一是通过<strong>“过程间分析”（Inter-Procedural Analysis，IPA，也经常被称为全程序分析，即Whole Program Analysis）</strong> <strong>来获得诸如某个程序点上某个变量的值是否一定为常量、某段代码块是否永远不可能被使用、在某个点调用的某个虚方法是否只能有单一版本等的分析结论</strong>。</p>
<p>这些信息对生成高质量的优化代码有着极为巨大的价值，但是要精确（譬如对流敏感、对路径敏感、对上下文敏感、对字段敏感）得到这些信息，必须<strong>在全程序范围内做大量极耗时的计算工作</strong>，目前所有常见的Java虚拟机对过程间分析的支持都相当有限：</p>
<ul>
<li><p>要么借助大规模的方法内联来打通方法间的隔阂，以过程内分析（Intra-Procedural Analysis，只考虑过程内部语句，不考虑过程调用的分析）来模拟过程间分析的部分效果；</p>
</li>
<li><p>要么借助可假设的激进优化，不求得到精确的结果，只求按照最可能的状况来优化，有问题再退回来解析执行。</p>
</li>
</ul>
<p><strong>但如果是在程序运行之前进行的静态编译，这些耗时的优化就可以放心大胆地进行了</strong>，譬如Graal VM中的Substrate VM，在创建本地镜像的时候，就会采取许多原本在HotSpot即时编译中并不会做的全程序优化措施以获得更好的运行时性能，反正做镜像阶段慢一点并没有什么大影响。</p>
<h4 id="提前编译的第二条路径"><a href="#提前编译的第二条路径" class="headerlink" title="提前编译的第二条路径"></a>提前编译的第二条路径</h4><p>本质是<strong>给即时编译器做缓存加速</strong>，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。</p>
<p>这种提前编译被称为<strong>动态提前编译（Dynamic AOT）</strong>或者索性就大大方方地直接叫即时<strong>编译缓存（JIT Caching）</strong>。在目前的Java技术体系里，这条路径的提前编译已经完全被主流的商用JDK支持。</p>
<p>真正引起业界普遍关注的是OpenJDK/OracleJDK 9中所带的<strong>Jaotc提前编译器</strong>，这是一个<strong>基于Graal编译器实现的新工具</strong>，目的是让<strong>用户可以针对目标机器，为应用程序进行提前编译</strong>。</p>
<p>HotSpot运行时可以直接加载这些编译的结果，实现加快程序启动速度，减少程序达到全速运行状态所需时间的目的。</p>
<ul>
<li>这里面确实有比较大的优化价值，试想一下，各种Java应用最起码会用到Java的标准类库，如java.base等模块，如果能够将这个类库提前编译好，并进行比较高质量的优化，显然能够节约不少应用运行时的编译成本。</li>
</ul>
<p>这的确是很好的想法，但实际应用起来并不是那么容易，原因是<strong>这种提前编译方式不仅要和目标机器相关</strong>，甚至<strong>还必须与HotSpot虚拟机的运行时参数绑定</strong>。</p>
<p>譬如虚拟机运行时采用了不同的垃圾收集器，这原本就需要即时编译子系统的配合（典型的如生成内存屏障代码，见第3章相关介绍）才能正确工作，要做提前编译的话，自然也要把这些配合的工作平移过去。</p>
<p>尽管还有许多困难，但<strong>提前编译无疑已经成为一种极限榨取性能（启动、响应速度）的手段</strong>。</p>
<p>最后，我们还要思考一个问题：提前编译的代码输出质量，一定会比即时编译更高吗？</p>
<p>提前编译因为没有执行时间和资源限制的压力，能够毫无顾忌地使用重负载的优化手段，这当然是一个极大的优势，但即时编译难道就没有能与其竞争的强项了吗？</p>
<h4 id="三种即时编译器相对于提前编译器的天然优势"><a href="#三种即时编译器相对于提前编译器的天然优势" class="headerlink" title="三种即时编译器相对于提前编译器的天然优势"></a>三种即时编译器相对于提前编译器的天然优势</h4><ul>
<li><strong>性能分析制导优化（Profile-Guided Optimization，PGO）</strong><ul>
<li>HotSpot的即时编译器时就多次提及<strong>在解释器或者客户端编译器运行过程中，会不断收集性能监控信息</strong>，譬如某个程序点抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等，<strong>这些数据一般在静态分析时是无法得到的</strong>，或者不可能存在确定且唯一的解，最多只能依照一些启发性的条件去进行猜测。但<strong>在动态运行时却能看出它们具有非常明显的偏好性</strong>。如果一个条件分支的某一条路径执行特别频繁，而其他路径鲜有问津，那就可以把热的代码集中放到一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>激进预测性优化（Aggressive Speculative Optimization）</strong><ul>
<li>这也已经成为很多即时编译优化措施的基础。</li>
<li><strong><u>静态优化</u>无论如何都必须保证优化后所有的程序外部可见影响（不仅仅是执行结果）与优化前是等效的，</strong>不然优化之后会导致程序报错或者结果不对，若出现这种情况，则速度再快也是没有价值的。</li>
<li><strong>相对于提前编译来说，即时编译的策略就可以不必这样保守</strong>，如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概率的假设进行优化，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果。<strong>只要出错概率足够低，这样的优化往往能够大幅度降低目标程序的复杂度，输出运行速度非常高的代码</strong>。</li>
</ul>
</li>
<li><strong>链接时优化（Link-Time Optimization，LTO）</strong><ul>
<li><strong>Java语言天生就是动态链接的</strong>，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后本地代码，这类事情在Java程序员眼里看起来毫无违和之处。</li>
<li>但如果类似的场景出现在使用提前编译的语言和程序上，譬 如<strong>C、C++的程序</strong>要调用某个动态链接库的某个方法，就会出现很明显的边界隔阂，还难以优化。这是因为<strong>主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码</strong>。</li>
</ul>
</li>
</ul>
<p>提前编译有它的应用场景，也有它的弱项与不足，相信未来很长一段时间内，即时编译和提前编译都会是Java后端编译技术的共同主角。</p>
<h3 id="11-3-2-实战：Jaotc的提前编译"><a href="#11-3-2-实战：Jaotc的提前编译" class="headerlink" title="11.3.2 实战：Jaotc的提前编译"></a>11.3.2 实战：Jaotc的提前编译</h3><h2 id="11-4-编译器优化技术"><a href="#11-4-编译器优化技术" class="headerlink" title="11.4 编译器优化技术"></a>11.4 编译器优化技术</h2><p>编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但其实<strong>难点并不在于能不能成功翻译出机器码，输出代码优化质量的高低才是决定编译器优秀与否的关键</strong>。</p>
<h3 id="11-4-1-优化技术概览"><a href="#11-4-1-优化技术概览" class="headerlink" title="11.4.1 优化技术概览"></a>11.4.1 优化技术概览</h3><p><img src="optimize-techology-table.png" alt="image-20220508160036567"></p>
<p><img src="optimize-techology-table2.png" alt="image-20220508160417816"></p>
<center>表11-1 即时编译器优化技术一览</center>

<p>首先需要明确一点，<strong>即时编译器对这些代码优化变换是建立在代码的中间表示或者是机器码之上的</strong>，绝不是直接在Java源码上去做的。</p>
<h4 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h4><p>代码清单11-6 优化前的原始代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    y = b.get();</span><br><span class="line">    <span class="comment">//...do stuff...</span></span><br><span class="line">    z = b.get();</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单11-6所示的内容已经非常简化了，但是仍有不少优化的空间。</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>第一个要进行的优化是<strong>方法内联</strong>，它的主要目的有两个：</p>
<ul>
<li><strong>一是去除方法调用的成本</strong>（如查找方法版本、建立栈帧等）;</li>
<li>二是<strong>为其他优化建立良好的基础</strong>。</li>
<li>方法内联膨胀之后可以便于在更大范围上进行后续的优化手段，可以获取更好的优化效果。因此**各种编译器一般都会把<u>内联优化放在优化序列最靠前的位置</u>**。</li>
</ul>
<p>内联后的代码如代码清单11-7所示</p>
<p>代码清单11-7 内联后的代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">//...do stuff...</span></span><br><span class="line">    z = b.value;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="冗余访问消除"><a href="#冗余访问消除" class="headerlink" title="冗余访问消除"></a>冗余访问消除</h4><p>第二步进行<strong>冗余访问消除（Redundant Loads Elimination）</strong>，假设代码中间注释掉的“…do stuff…”所代表的操作不会改变b.value的值，那么就可以把“z=b.value”替换为“z=y”，因为上一句“y=b.value”已经保证了变量y与b.value是一致的，这样就可以不再去访问对象b的局部变量了。如果把b.value看作一个表达式，那么也可以把这项优化看作一种<strong>公共子表达式消除（Common Subexpression Elimination）</strong>，优化后的代码如代码清单11-8所示。 </p>
<p>代码清单11-8 冗余存储消除的代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">//...do stuff...</span></span><br><span class="line">    z = y;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="复写传播"><a href="#复写传播" class="headerlink" title="复写传播"></a>复写传播</h4><p>第三步进行<strong>复写传播（Copy Propagation）</strong>，因为这段程序的逻辑之中没有必要使用一个额外的变量z，它与变量y是完全相等的，因此我们可以使用y来代替z。复写传播之后的程序如代码清单11-9所示。</p>
<p>代码清单11-9 复写传播的代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">//...do stuff...</span></span><br><span class="line">    y = y;</span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="无用代码消除"><a href="#无用代码消除" class="headerlink" title="无用代码消除"></a>无用代码消除</h4><p>第四步进行<strong>无用代码消除（Dead Code Elimination）</strong>，无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码。因此它又被很形象地称为“Dead Code”，在代码清单11-9中，“y=y”是没有意义的，把它消除后的程序如代码清单11-10所示。 </p>
<p>代码清单11-10 进行无用代码消除的代码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">//...do stuff...</span></span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过四次优化之后，代码清单11-10所示代码与代码清单11-6所示代码所达到的效果是一致的，但是前者比后者省略了许多语句，体现在字节码和机器码指令上的差距会更大，执行效率的差距也会更高。</p>
<p>四项有代表性的优化技术:</p>
<ul>
<li><p><strong>最重要的优化技术之一：方法内联。</strong> </p>
</li>
<li><p><strong>最前沿的优化技术之一：逃逸分析。</strong> </p>
</li>
<li><p><strong>语言无关的经典优化技术之一：公共子表达式消除。</strong> </p>
</li>
<li><p><strong>语言相关的经典优化技术之一：数组边界检查消除。</strong></p>
</li>
</ul>
<h3 id="11-4-2-方法内联"><a href="#11-4-2-方法内联" class="headerlink" title="11.4.2 方法内联"></a>11.4.2 方法内联</h3><p>内联被业内戏称为优化之母，因为除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。</p>
<p>代码清单11-11 未作任何优化的字节码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testInline</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    foo(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码清单11-11所示的简单例子就揭示了内联对其他优化手段的巨大价值：<strong>没有内联，多数其他优化都无法有效进行</strong>。</p>
<p>例子里testInline()方法的内部全部是无用的代码，但如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何“Dead Code”的存在。如果分开来看，foo()和testInline()两个方法里面的操作都有可能是有意义的。 </p>
<p>方法内联的优化行为理解起来是没有任何困难的，不过就是把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用而已。</p>
<p><strong>但实际上Java虚拟机中的内联过程却远没有想象中容易，甚至如果不是即时编译器做了一些特殊的努力，按照经典编译原理的优化理论，大多数的Java方法都无法进行内联。</strong> </p>
<p>无法内联的原因其实在第8章中讲解<strong>Java方法解析和分派调用</strong>的时候就已经解释过：</p>
<ul>
<li>只有使用<strong>invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法</strong>才会在<strong>编译期</strong>进行解析。</li>
<li>除了上述四种方法之外（最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法，《Java语言规范》中明确说明了这点），<strong>其他的Java方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，</strong>简而言之，**<u>Java语言中默认的实例方法是虚方法</u>**。 </li>
</ul>
<p><strong>对于一个虚方法，编译器静态地去做内联的时候很难确定应该使用哪个方法版本。</strong></p>
<p>由于Java提倡使用面向对象的方式进行编程，<strong>而Java对象的方法默认就是虚方法</strong>，可以说Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑。根据上面的分析可知，<strong>内联与虚方法之间会产生“矛盾”</strong>，那是不是为了提高执行性能，就应该默认给每个方法都使用final关键字去修饰呢？C和C++语言的确是这样做的，默认的方法是非虚方法，如果需要用到多态，就用virtual关键字来修饰，但Java选择了在虚拟机中解决这个问题。</p>
<h4 id="类型继承关系分析（Class-Hierarchy-Analysis，CHA）"><a href="#类型继承关系分析（Class-Hierarchy-Analysis，CHA）" class="headerlink" title="类型继承关系分析（Class Hierarchy Analysis，CHA）"></a>类型继承关系分析（Class Hierarchy Analysis，CHA）</h4><p>为了<strong>解决虚方法的内联问题</strong>，Java虚拟机首先引入了一种名为<strong>类型继承关系分析（Class Hierarchy Analysis，CHA）的技术</strong>，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，<strong>某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息</strong>。</p>
<ul>
<li><p>如果是<strong>非虚方法</strong>，那么<strong>直接进行内联</strong>就可以了，这种的内联是有百分百安全保障的；</p>
</li>
<li><p>如果遇到虚方法，则会<strong>向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择</strong>，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为<strong>守护内联（Guarded Inlining）</strong>。</p>
<ul>
<li>不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此<strong>这种内联属于激进预测性优化</strong>，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。</li>
<li>假如在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。</li>
<li><strong>如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</strong></li>
</ul>
</li>
<li><p>假如向CHA查询出来的结果是该方法确实<strong>有多个版本的目标方法可供选择</strong>，那即时编译器还将进行最后一次努力，<strong>使用内联缓存（Inline Cache）的方式来缩减方法调用的开销</strong>。这种状态下方法调用是真正发生了的，但是<strong>比起直接查虚方法表还是要快一些</strong>。<strong>内联缓存是一个建立在目标方法正常入口之前的缓存</strong>，它的工作原理大致为：</p>
<ul>
<li><p>在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种<strong>单态内联缓存（Monomorphic Inline Cache）</strong>。通过该缓存来调用，<strong>比用不内联的非虚方法调用，仅多了一次<u>类型判断的开销</u>而已</strong>。</p>
</li>
<li><p>但如果真的出现方法接收者不一致的情况，就说明程序用到了<strong>虚方法的多态特性</strong>，这时候会退化成<strong>超多态内</strong> </p>
<p><strong>联缓存（Megamorphic Inline Cache）</strong>，<strong>其开销相当于真正查找虚方法表来进行方法分派</strong>。 </p>
</li>
</ul>
</li>
</ul>
<p>在多数情况下**Java虚拟机进行的<u>方法内联都是一种激进优化</u>**。事实上，激进优化的应用在高性能的Java虚拟机中比比皆是，极为常见。</p>
<p>除了方法内联之外，对于出现概率很小（通过经验数据或解释器收集到的性能监控信息确定概率大小）的隐式异常、使用概率很小的分支等都可以被激进优化“移除”，如果真的出现了小概率事件，这时才会从“逃生门”回到解释状态重新执行。</p>
<h3 id="11-4-3-逃逸分析"><a href="#11-4-3-逃逸分析" class="headerlink" title="11.4.3 逃逸分析"></a>11.4.3 逃逸分析</h3><p><strong>逃逸分析（Escape Analysis）</strong>是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，<strong>并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术</strong>。 </p>
<p>逃逸分析的基本原理是：**分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为<u>方法逃逸</u>**；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。 </p>
<p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，如： </p>
<ul>
<li><p><strong>栈上分配（Stack Allocations）：</strong></p>
<ul>
<li>在Java虚拟机中，Java堆上分配创建对象的内存空间几乎是Java程序员都知道的常识，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。</li>
<li>虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但<strong>回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源</strong>。如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。</li>
<li>在一般应用中，<strong>完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多</strong>。</li>
<li><strong>栈上分配可以支持方法逃逸，但不能支持线程逃逸。</strong></li>
</ul>
</li>
<li><p><strong>标量替换（Scalar Replacement）:</strong></p>
<ul>
<li>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为<strong>标量</strong>。</li>
<li>相对的，如果一个数据可以继续分解，那它就被称为<strong>聚合量（Aggregate）</strong>，<strong>Java中的对象就是典型的聚合量</strong>。</li>
<li>如果<strong>把一个Java对象拆散</strong>，根据程序访问的情况，<strong>将其用到的成员变量恢复为原始类型来访问</strong>，**这个过程就称为<u>标量替换</u>**。</li>
<li>假如逃逸分析能够证明<strong>一个对象不会被方法外部访问</strong>，并且<strong>这个对象可以被拆散</strong>，<strong>那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替</strong>。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。<strong>标量替换可以视作栈上分配的一种特例</strong>，实现更简单（不用考虑整个对象完整结构的分配），<strong>但对逃逸程度的要求更高</strong>，它<strong>不允许对象逃逸出方法范围内</strong>。 </li>
</ul>
</li>
<li><p><strong>同步消除（Synchronization Elimination）:</strong></p>
<ul>
<li>线程同步本身是一个相对耗时的过程，<strong>如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉</strong>。 </li>
</ul>
</li>
</ul>
<p><strong>逃逸分析的计算成本非常高，甚至不能保证逃逸分析带来的性能收益会高于它的消耗。</strong></p>
<h3 id="11-4-4-公共子表达式消除"><a href="#11-4-4-公共子表达式消除" class="headerlink" title="11.4.4 公共子表达式消除"></a>11.4.4 公共子表达式消除</h3><p>公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为<strong>公共子表达式</strong>。</p>
<p>如果这种优化仅限于程序基本块内，便可称为<strong>局部公共子表达式消除（Local Common Subexpression Elimination）</strong>，如果这种优化的范围涵盖了多个基本块，那就称为<strong>全局公共子表达式消除（Global Common Subexpression Elimination）</strong>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> (c * b) * <span class="number">12</span> + a + (a + b * c);</span><br></pre></td></tr></table></figure>

<p>如果这段代码交给Javac编译器则不会进行任何优化，那生成的代码将如代码清单11-12所示，是完全遵照Java源码的写法直译而成的。</p>
<p>代码清单11-12 未作任何优化的字节码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iload_2 <span class="comment">// b </span></span><br><span class="line">   imul <span class="comment">// 计算b*c </span></span><br><span class="line">   bipush <span class="number">12</span> <span class="comment">// 推入12 </span></span><br><span class="line">   imul <span class="comment">// 计算(c * b) * 12 </span></span><br><span class="line">   iload_1 <span class="comment">// a </span></span><br><span class="line">   iadd <span class="comment">// 计算(c * b) * 12 + a </span></span><br><span class="line">   iload_1 <span class="comment">// a </span></span><br><span class="line">   iload_2 <span class="comment">// b </span></span><br><span class="line">   iload_3 <span class="comment">// c </span></span><br><span class="line">   imul <span class="comment">// 计算b * c </span></span><br><span class="line">   iadd <span class="comment">// 计算a + b * c </span></span><br><span class="line">   iadd <span class="comment">// 计算(c * b) * 12 + a + a + b * c </span></span><br><span class="line">   istore <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>当这段代码进入虚拟机即时编译器后，它将进行如下优化：编译器检测到c*b与b*c是一样的表达式，而且在计算期间b与c的值是不变的。 </p>
<p>因此这条表达式就可能被视为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> E * <span class="number">12</span> + a + (a + E);</span><br></pre></td></tr></table></figure>

<p>这时候，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化——<strong>代数化简（Algebraic Simplification）</strong>，在E本来就有乘法运算的前提下，把表达式变为： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> E * <span class="number">13</span> + a + a;</span><br></pre></td></tr></table></figure>





<h3 id="11-4-5-数组边界检查消除"><a href="#11-4-5-数组边界检查消除" class="headerlink" title="11.4.5 数组边界检查消除"></a>11.4.5 数组边界检查消除</h3><p><strong>数组边界检查消除（Array Bounds Checking Elimination）</strong>是<strong>即时编译器中</strong>的一项<strong>语言相关的经典优化技术</strong>。</p>
<p>无论如何，为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次不漏地进行则是可以“商量”的事情。例如下面这个简单的情况：数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下标“3”没有越界，执行的时候就无须判断了。</p>
<p>更加常见的情况是，数组访问发生在循环之中，并且使用循环变量来进行数组的访问。<strong>如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length)之内，那么在循环中就可以把整个数组的上下界检查消除掉</strong>，这可以节省很多次的条件判断操作。 </p>
<p>与语言相关的其他消除操作还有不少，如<strong>自动装箱消除（Autobox Elimination）</strong>、<strong>安全点消除（Safepoint Elimination）</strong>、<strong>消除反射（Dereflection）</strong>等</p>
<h2 id="11-5-实战：深入理解Graal编译器"><a href="#11-5-实战：深入理解Graal编译器" class="headerlink" title="11.5 实战：深入理解Graal编译器"></a>11.5 实战：深入理解Graal编译器</h2><p>Graal编译器使用于Java语言来编写。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://dstrive06.github.io">dstrive</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dstrive06.github.io/blog/8c72b87b40d9/">https://dstrive06.github.io/blog/8c72b87b40d9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dstrive06.github.io" target="_blank">dstrive</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/5b9a996050a2/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第12章 Java内存模型与线程</div></div></a></div><div class="next-post pull-right"><a href="/blog/1ee8bf0cee08/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第10章 前端编译与优化</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dstrive</div><div class="author-info__description">个人博客，记录笔记</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dstrive06"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记录笔记，记录技术点滴，持续学习...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">11.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">11.2 即时编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">11.2.1 解释器与编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E7%BC%96%E8%AF%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">11.2.2 编译对象与触发条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">方法调用计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">回边计数器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">11.2.3 编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E2%80%94%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">后端编译—客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5"><span class="toc-text">第一阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5"><span class="toc-text">第二阶段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5"><span class="toc-text">第三阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E2%80%94%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">后端编译—服务端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9F%A5%E7%9C%8B%E5%8F%8A%E5%88%86%E6%9E%90%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C"><span class="toc-text">11.2.4 实战：查看及分析即时编译结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">11.3 提前编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%B7%AF%E5%BE%84"><span class="toc-text">提前编译的第一条路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%B7%AF%E5%BE%84"><span class="toc-text">提前编译的第二条路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%A9%E7%84%B6%E4%BC%98%E5%8A%BF"><span class="toc-text">三种即时编译器相对于提前编译器的天然优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-2-%E5%AE%9E%E6%88%98%EF%BC%9AJaotc%E7%9A%84%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91"><span class="toc-text">11.3.2 实战：Jaotc的提前编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-text">11.4 编译器优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-1-%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88"><span class="toc-text">11.4.1 优化技术概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95"><span class="toc-text">代码清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-text">方法内联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E8%AE%BF%E9%97%AE%E6%B6%88%E9%99%A4"><span class="toc-text">冗余访问消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%86%99%E4%BC%A0%E6%92%AD"><span class="toc-text">复写传播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%94%A8%E4%BB%A3%E7%A0%81%E6%B6%88%E9%99%A4"><span class="toc-text">无用代码消除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-2-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-text">11.4.2 方法内联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90%EF%BC%88Class-Hierarchy-Analysis%EF%BC%8CCHA%EF%BC%89"><span class="toc-text">类型继承关系分析（Class Hierarchy Analysis，CHA）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-3-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">11.4.3 逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-4-%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4"><span class="toc-text">11.4.4 公共子表达式消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-5-%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5%E6%B6%88%E9%99%A4"><span class="toc-text">11.4.5 数组边界检查消除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E5%AE%9E%E6%88%98%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Graal%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">11.5 实战：深入理解Graal编译器</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/09209b9f0712/" title="Mybatis执行流程"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis执行流程"/></a><div class="content"><a class="title" href="/blog/09209b9f0712/" title="Mybatis执行流程">Mybatis执行流程</a><time datetime="2022-05-18T13:25:33.000Z" title="发表于 2022-05-18 21:25:33">2022-05-18</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/blog/1f7ff14317f9/" title="第13章 线程安全与锁优化">第13章 线程安全与锁优化</a><time datetime="2022-05-18T12:58:12.000Z" title="发表于 2022-05-18 20:58:12">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/5b9a996050a2/" title="第12章 Java内存模型与线程"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第12章 Java内存模型与线程"/></a><div class="content"><a class="title" href="/blog/5b9a996050a2/" title="第12章 Java内存模型与线程">第12章 Java内存模型与线程</a><time datetime="2022-05-18T12:58:08.000Z" title="发表于 2022-05-18 20:58:08">2022-05-18</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/blog/8c72b87b40d9/" title="第11章 后端编译与优化">第11章 后端编译与优化</a><time datetime="2022-05-18T12:57:36.000Z" title="发表于 2022-05-18 20:57:36">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/1ee8bf0cee08/" title="第10章 前端编译与优化"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第10章 前端编译与优化"/></a><div class="content"><a class="title" href="/blog/1ee8bf0cee08/" title="第10章 前端编译与优化">第10章 前端编译与优化</a><time datetime="2022-05-18T00:22:06.000Z" title="发表于 2022-05-18 08:22:06">2022-05-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By dstrive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">hello，welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
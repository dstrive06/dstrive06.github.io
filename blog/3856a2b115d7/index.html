<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第6章 类文件结构 | dstrive</title><meta name="keywords" content="jvm"><meta name="author" content="dstrive"><meta name="copyright" content="dstrive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。">
<meta property="og:type" content="article">
<meta property="og:title" content="第6章 类文件结构">
<meta property="og:url" content="https://dstrive06.github.io/blog/3856a2b115d7/index.html">
<meta property="og:site_name" content="dstrive">
<meta property="og:description" content="代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg">
<meta property="article:published_time" content="2022-04-09T12:56:26.000Z">
<meta property="article:modified_time" content="2022-04-09T12:56:26.000Z">
<meta property="article:author" content="dstrive">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dstrive06.github.io/blog/3856a2b115d7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: dstrive","link":"链接: ","source":"来源: dstrive","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第6章 类文件结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-04-09 20:56:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">dstrive</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第6章 类文件结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-09T12:56:26.000Z" title="发表于 2022-04-09 20:56:26">2022-04-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-09T12:56:26.000Z" title="更新于 2022-04-09 20:56:26">2022-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/">《深入理解Java虚拟机》</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/%E7%AC%AC%E5%85%AD%E7%AB%A0/">第六章</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第6章 类文件结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第6章-类文件结构"><a href="#第6章-类文件结构" class="headerlink" title="第6章 类文件结构"></a>第6章 类文件结构</h1><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不与包括Java语言在内的任何程序语言绑定，它<strong>只与“Class文件”这种特定的二进制文件格式所关联</strong>，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。</p>
<p>基于安全方面的考虑，《Java虚拟机规范》中要求在Class文件必须应用许多强制性的语法和结构化约束，但<strong>图灵完备的字节码格式</strong>，<strong>保证了任意一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件</strong>。</p>
<p>作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，<strong>以Class文件作为他们产品的交付媒介</strong>。</p>
<p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，<strong>这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行</strong>。</p>
<p><img src="jvm-language-irrelevancy.png" alt="image-20220409213005006"></p>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>Java技术能够一直保持着非常良好的向后兼容性，<strong>Class文件结构的稳定功不可没</strong>，任何一门程序语言能够获得商业上的成功，都不可能去做升级版本后，旧版本编译的产品就不再能够运行这种事情。</p>
<blockquote>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是反过来说，<strong>类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）</strong>。本章中，作者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，<strong>实际上它完全不需要以磁盘文件的形式存在</strong>。</p>
</blockquote>
<p>Class文件是一组<strong>以8个字节为基础单位的二进制流</strong>，各个数据项目严格按照顺序紧凑地排列在文件之中，<strong>中间没有添加任何分隔符</strong>，这使得<strong>整个Class文件中存储的内容几乎全部是程序运行的必要数据</strong>，没有空隙存在。</p>
<p>当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[^1]的方式分割成若干个8个字节进行存储。 </p>
<p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“<strong>无符号数</strong>”和“<strong>表</strong>”。</p>
<h4 id="class文件数据类型（无符号数和表）"><a href="#class文件数据类型（无符号数和表）" class="headerlink" title="class文件数据类型（无符号数和表）"></a>class文件数据类型（无符号数和表）</h4><ul>
<li><strong>无符号数（可以理解为字面量？）</strong><ul>
<li>属于<strong>基本的数据类型</strong>，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述<strong>数字</strong>、<strong>索引引用</strong>、<strong>数量值</strong>或者按照<strong>UTF-8编码构成字符串值</strong>。</li>
</ul>
</li>
<li><strong>表</strong><ul>
<li><strong>由多个无符号数或者其他表作为数据项构成的复合数据类型</strong>，为了便于区分，所有表的命名 都习惯性地<strong>以“_info”结尾</strong>。表用于描述有层次关系的复合结构的数据，<strong>整个Class文件本质上也可以视作是一张表</strong>，这张表由表6-1所示的数据项按严格顺序排列构成。 </li>
</ul>
</li>
</ul>
<p>[^1]: 这种顺序称为“Big-Endian”，具体顺序是指按高位字节在地址最低位，最低字节在地址最高位来存 储数据，它是SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处理器则是使用了相反的“Little-Endian”顺序来存储数据。</p>
<h3 id="表6-1-Class文件格式"><a href="#表6-1-Class文件格式" class="headerlink" title="表6-1 Class文件格式"></a>表6-1 Class文件格式</h3><p><img src="class-bytecode-pattern.png" alt="class-bytecode-pattern"></p>
<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个<strong>前置的容量计数器</strong>加<strong>若干个连续的数据项</strong>的形式，这时候称这<strong>一系列连续的某一类型的数据为某一类型的“集合”</strong>。</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>每个Class文件的<strong>头4个字节被称为魔数（Magic Number）</strong>，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>
<p>不仅是Class文件，很多文件格式标准中都有使用<strong>魔数</strong>来进行身份识别的习惯，譬如图片格式，如GIF或者JPEG等在文件头中都存有魔数。使用<strong>魔数</strong>而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。</p>
<p>Class文件的魔数取得很有“浪漫气息”，值为<strong>0xCAFEBABE</strong>（咖啡宝贝？）。</p>
<p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。</p>
<p>《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，<strong>虚拟机也必须拒绝执行超过其版本号的Class文件。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dw.six_class_structure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="TestClass-byte-code.png" alt="TestClass-byte-code2"></p>
<center>图6-3TestClass字节码文件</center>

<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。 </p>
<p>由于<strong>常量池中常量的数量是不固定</strong>的，所以在<strong>常量池的入口需要放置一项u2类型的数据</strong>，代表常量池容量计数值（constant_pool_count）。</p>
<p>这个<strong>容量计数是从1而不是0开始的</strong>，如图6-3所示，<strong>常量池容量</strong>（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。</p>
<p><strong>Class文件结构中只有常量池的容量计数是从1开始</strong>，<strong>对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始</strong>。</p>
<p>常量池中主要存放两大类常量：</p>
<ul>
<li>字面量（Literal）： 字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值。</li>
<li>符号引用（Symbolic References）：符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/dw/six_class_structure/TestClass</span><br><span class="line">   #2 = Utf8               com/dw/six_class_structure/TestClass</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               m</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Methodref          #3.#11         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lcom/dw/six_class_structure/TestClass;</span><br><span class="line">  #16 = Utf8               inc</span><br><span class="line">  #17 = Utf8               ()I</span><br><span class="line">  #18 = Fieldref           #1.#19         // com/dw/six_class_structure/TestClass.m:I</span><br><span class="line">  #19 = NameAndType        #5:#6          // m:I</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               TestClass.java</span><br></pre></td></tr></table></figure>

<p>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行<strong>动态连接</strong>（具体见第7章）。也就是说，<strong>在Class文件中不会保存各个方法、字段最终在内存中的布局信息</strong>，<strong>这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的</strong>。<strong>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</strong>。</p>
<p><strong>常量池中每一项常量都是一个表</strong>，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持<strong>动态语言调用</strong>，额外增加了4种动态语言相关的常量[^2]，为了支持<strong>Java模块化系统（Jigsaw）</strong>，又加入了<strong>CONSTANT_Module_info</strong>和<strong>CONSTANT_Package_info</strong>两个常量，所以截至JDK 13，常量表中分别有17种不同类型的常量。</p>
<p>这17类表都有一个共同的特点，<strong>表结构起始的第一位是个u1类型的标志位</strong>（<strong>tag</strong>，取值见表6-3中标志列），<strong>代表着当前常量属于哪种常量类型</strong>。17种常量类型所代表的具体含义如表6-3所示。</p>
<p><img src="constant-pool-tag-type.png" alt="constant-pool-type"></p>
<p>之所以说<strong>常量池是最烦琐的数据</strong>，是因为<strong>这17种常量类型各自有着完全独立的数据结构</strong>，<strong>两两之间并没有什么共性和联系</strong>，因此只能逐项进行讲解。 </p>
<p>如图：</p>
<p>常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表6-3的标志列可知这个常量属于CONSTANT_Class_info类型，<strong>此类型的常量代表一个类或者接口的符号引用</strong>。</p>
<p><img src="TestClass-byte-code2.png" alt="TestClass-byte-code2"></p>
<center>图6-3TestClass字节码文件</center>



<h4 id="CONSTANT-Class-info的结构比较简单，如表6-4所示。"><a href="#CONSTANT-Class-info的结构比较简单，如表6-4所示。" class="headerlink" title="CONSTANT_Class_info的结构比较简单，如表6-4所示。"></a>CONSTANT_Class_info的结构比较简单，如表6-4所示。</h4><p><img src="constant_class_info.png" alt="constant_class_info"></p>
<ul>
<li><p><strong>tag是标志位，它用于区分常量类型；</strong></p>
</li>
<li><p><strong>name_index是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info类型常量</strong>，此常量代表了这个类（或者接口）的全限定名，本例中的name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量。继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个<strong>CONSTANT_Utf8_info类型</strong>的常量。CONSTANT_Utf8_info类型的结构如表6-5所示。 </p>
</li>
</ul>
<p><img src="constant-utf8-info.png" alt="constant-utf8-info"></p>
<p>length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。</p>
<ul>
<li>UTF-8缩略编码与普通UTF-8编码的区别是： <ul>
<li>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示</li>
<li>从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示</li>
<li>从’\u0800’开始到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。 </li>
</ul>
</li>
</ul>
<p>顺便提一下，由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以<strong>CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。</strong></p>
<p>而这里的<strong>最大长度就是length的最大值</strong>，既<strong>u2类型能表达的最大值65535</strong>。<strong>所以Java程序中如果定义了超过64KB英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</strong> </p>
<p>本例中这个字符串的length值为0x0024，也就是长36个字节，往后36个字节正好都在1～127的ASCII码范围以内，内容为“com/dw/six_class_structure/TestClass”</p>
<p><img src="constant-utf8-info-class-str.png" alt="constant-utf8-info-class-str"></p>
<blockquote>
<p> 专门用于分析Class文件字节码的工具：<strong>javap</strong></p>
</blockquote>
<h5 id="代码清单6-2-使用javap命令输出常量表"><a href="#代码清单6-2-使用javap命令输出常量表" class="headerlink" title="代码清单6-2 使用javap命令输出常量表"></a>代码清单6-2 使用javap命令输出常量表</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">E:\java_work_space\java_se\deep-understanding-jvm\bin\com\dw\six_class_structure&gt;javap -verbose TestClass</span><br><span class="line">警告: 二进制文件TestClass包含com.dw.six_class_structure.TestClass</span><br><span class="line">Classfile /E:/java_work_space/java_se/deep-understanding-jvm/bin/com/dw/six_class_structure/TestClass.class</span><br><span class="line">  Last modified 2021-3-17; size 407 bytes</span><br><span class="line">  MD5 checksum 3a70b4dec2730574514133f6404ba44e</span><br><span class="line">  Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class com.dw.six_class_structure.TestClass</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/dw/six_class_structure/TestClass</span><br><span class="line">   #2 = Utf8               com/dw/six_class_structure/TestClass</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               m</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Methodref          #3.#11         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lcom/dw/six_class_structure/TestClass;</span><br><span class="line">  #16 = Utf8               inc</span><br><span class="line">  #17 = Utf8               ()I</span><br><span class="line">  #18 = Fieldref           #1.#19         // com/dw/six_class_structure/TestClass.m:I</span><br><span class="line">  #19 = NameAndType        #5:#6          // m:I</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               TestClass.java</span><br><span class="line">&#123;</span><br><span class="line">  public com.dw.six_class_structure.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/dw/six_class_structure/TestClass;</span><br><span class="line"></span><br><span class="line">  public int inc();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #18                 // Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  this   Lcom/dw/six_class_structure/TestClass;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;TestClass.java&quot;</span><br></pre></td></tr></table></figure>

<p>从代码清单6-2中可以看到，计算机已经帮我们把整个常量池的21项常量都计算了出来，并且第 1、2项常量的计算结果与我们手工计算的结果完全一致。仔细看一下会发现，其中有些常量似乎从来没有在代码中出现过，如<strong>“I” “V” “&lt;init&gt;” “LineNumberTable” “LocalVariableTable”</strong>等，这些看起来在源代码中不存在的常量是哪里来的？ </p>
<p>这部分常量的确不来源于Java源代码，它们<strong>都是编译器自动生成</strong>的，会被后面即将讲到的<strong>字段表（field_info）</strong>、<strong>方法表（method_info）</strong>、<strong>属性表（attribute_info）</strong>所引用，它们将会被用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么。</p>
<p><strong>因为Java中的“类”是无穷无尽的，无法通过简单的无符号数来描述一个方法用到了什么类</strong>，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达。这部分内容将在后面进一步详细阐述。最后，笔者将17种常量项的结构定义总结为表6-6。 </p>
<p>表6-6 常量池中的17种数据类型的结构总表</p>
<p><img src="constant-pool-type-detail.png" alt="constant-pool-type-detail"></p>
<p><img src="constant-pool-type-detail2.png" alt="constant-pool-type-detail2"><img src="constant-pool-type-detail3.png" alt="constant-pool-type-detail3"></p>
<p>[^2]: JDK 7时增加了前三种：<strong>CONSTANT_MethodHandle_info</strong>、<strong>CONSTANT_MethodType_info</strong>和<strong>CONSTANT_InvokeDynamic_info</strong>。出于性能和易用性的考虑（JDK 7设计时已经考虑到，预留了17个 常量标志位），在JDK 11中又增加了第四种常量CONSTANT_Dynamic_info。本章不会涉及这4种新增的类型，留待第8章介绍字节码执行和方法调用时详细讲解。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的<strong>2个字节代表访问标志（access_flags）</strong>，这个标志用于识别一些类或者接口层次的访问信息</p>
<p>包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；</p>
<p>表6-7 访问标志 </p>
<p><img src="access-flag.png" alt="access-flag"></p>
<p>access_flags中一共有16个标志位可以使用，当前只定义了其中9个[^3]，没有使用到的标志位要求一律为零。以代码清单6-1中的代码为例，TestClass是一个普通Java类，不是接口、枚举、注解或者模块，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而ACC_FINAL、ACC_INTERFACE、 ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_MODULE这七个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。从图6-5中看到，access_flags标志（偏移地址：0x000000EF）的确为0x0021。 </p>
<p><img src="TestClass-access-flag.png" alt="image-20220410164725202"></p>
<p>[^3]: 在原始的《Java虚拟机规范》初版中，只定义了开头5种标志。JDK 5中增加了后续3种。这些标志 为在JSR-202规范之中声明，是对《Java虚拟机规范》第2版的补充。JDK 9发布之后，增加了第9种。</p>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p><strong>类索引（this_class）</strong>和<strong>父类索引（super_class）</strong>都是一个<strong>u2类型的数据</strong>，而<strong>接口索引集合 （interfaces）是一组u2类型的数据的集合</strong>，Class文件中<strong>由这三项数据来确定该类型的继承关系</strong>。</p>
<p><strong>类索引</strong>用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>
<p>由于Java语言不允许多重继承，所以<strong>父类索引</strong>只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此<strong>除了java.lang.Object外，所有Java类的父类索引都不为0</strong>。</p>
<p><strong>接口索引集合</strong>就用来描述这个类实现了哪些接口，这些被实现的接口将按<strong>implements关键字</strong>（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。 </p>
<p><strong>类索引</strong>、<strong>父类索引</strong>和<strong>接口索引</strong>集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。图6-6演示了代码清单6-1中代码的类索引查找过程。 </p>
<p><img src="class-index-map.png" alt="image-20220410165403445"></p>
<p>对于接口索引集合，<strong>入口的第一项u2类型的数据为接口计数器（interfaces_count）</strong>，表示<strong>索引表的容量</strong>。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p>
<p><img src="TestClass-class-index.png" alt="image-20220410170221445"></p>
<center>图6-7 类索引、父类索引、接口索引集合</center>

<p>从偏移地址0x0000000FF开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是类索引为1，父类索引为3，接口索引集合大小为0。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // com/dw/six_class_structure/TestClass</span><br><span class="line">   #2 = Utf8               com/dw/six_class_structure/TestClass</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>



<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p><strong>字段表（field_info）</strong>用于描述<strong>接口</strong>或者<strong>类</strong>中声明的<strong>变量</strong>。</p>
<p>Java语言中的“字段”（Field）包括<strong>类级变量（静态变量）</strong>以及<strong>实例级变量</strong>，但不包括在方法内部声明的局部变量。</p>
<p>字段可以包括的修饰符有</p>
<ul>
<li><strong>字段的作用域（public、private、protected修饰 符）</strong></li>
<li><strong>是实例变量还是类变量（static修饰符）</strong></li>
<li><strong>可变性（final）</strong></li>
<li><strong>并发可见性（volatile修饰符，是否强制从主内存读写）</strong></li>
<li><strong>可否被序列化（transient修饰符）</strong></li>
<li>字段数据类型（基本类型、对象、数组）</li>
<li>字段名称</li>
</ul>
<p>上述这些信息中，各个修饰符都是<strong>布尔值</strong>，要么有某个修饰符，要么没有，很<strong>适合使用标志位</strong>来表示。</p>
<p>而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<p>表6-8中列出了字段表的最终格式。 </p>
<p><img src="field-table.png" alt="image-20220410170953218"></p>
<p><strong>字段修饰符放在access_flags项目</strong>中，<strong>它与类中的access_flags项目是非常类似的</strong>，都是一个<strong>u2的数据类型</strong>，其中可以设置的标志位和含义如表6-9所示。 </p>
<p><img src="field-access-flag.png" alt="image-20220410171113572"></p>
<p>很明显，由于语法规则的约束：</p>
<ul>
<li><strong>ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一</strong></li>
<li><strong>ACC_FINAL、ACC_VOLATILE不能同时选择</strong></li>
<li><strong>接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志</strong></li>
</ul>
<p>这些都是由Java本身的语言规则所导致的。</p>
<p>跟随access_flags标志的是两项<strong>索引值</strong>：</p>
<ul>
<li><p><strong>name_index</strong>（字段的简单名称）</p>
</li>
<li><p><strong>descriptor_index</strong>（字段和方法的描述符）</p>
</li>
</ul>
<p>它们<strong>都是对常量池项的引用</strong>，分别代表着<strong>字段的简单名称</strong>以及<strong>字段和方法的描述符</strong>。</p>
<h4 id="字段和方法的描述符"><a href="#字段和方法的描述符" class="headerlink" title="字段和方法的描述符"></a>字段和方法的描述符</h4><p>用来描述<strong>字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</strong></p>
<p>根据描述符规则，</p>
<ul>
<li><strong>基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示</strong>，</li>
<li>而<strong>对象类型</strong>则用<strong>字符L加对象的全限定名</strong>来表示，详见表6-10。</li>
</ul>
<p><img src="field-or-method-descriptor.png" alt="image-20220410172012421"></p>
<p>注：void类型在《Java虚拟机规范》之中单独列出为“<strong>VoidDescriptor</strong>”，作者为了结构统一，将其列 在基本数据类型中一起描述。 </p>
<p>对于<strong>数组类型</strong>，每一维度将使用一个前置的==“[”==字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。 </p>
<p>用<strong>描述符来描述方法</strong>时，按照<strong>先参数列表</strong>、<strong>后返回值</strong>的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。</p>
<p>如</p>
<ul>
<li>方法void inc()的描述符为“()V”，</li>
<li>方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，</li>
<li>方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</li>
</ul>
<p>对于代码清单6-1所编译的TestClass.class文件来说，</p>
<ul>
<li>字段表集合从地址0x00000105开始，第一个<strong>u2类型</strong>的数据为容量计数器<strong>fields_count</strong>，如图6-8所示，其值为0x0001，说明这个类只有一个字段表数据。</li>
<li>接下来紧跟着容量计数器的是<strong>access_flags标志</strong>，值为0x0002，代表private<strong>修饰符</strong>的ACC_PRIVATE<strong>标志位</strong>为真（<strong>ACC_PRIVATE标志的值为0x0002</strong>），其他修饰符为假。</li>
<li>代表<strong>字段名称</strong>的<strong>name_index</strong>的值为0x0005，从代码清单6-2列出的常量表中可查得第五项常量是一个<strong>CONSTANT_Utf8_info类型的字符串</strong>，其值为“m”，</li>
<li>代表<strong>字段描述符</strong>的<strong>descriptor_index</strong>的值为0x0006，指向常量池的字符串“I”。</li>
</ul>
<p>根据这些信息，我们可以推断出原代码定义的字段为“private int m；”。</p>
<p>图6-8 字段表结构实例 </p>
<p><img src="TestClass-field-description.png" alt="image-20220410173328558"></p>
<p>字段表所包含的固定数据项目到descriptor_index为止就全部结束了，不过在descriptor_index之后跟随着一个<strong>属性表集合</strong>，用于存储一些额外的信息，<strong>字段表可以在属性表中附加描述零至多项的额外信息</strong>。对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信息，但是，<u>如果将字段m的声明改为“final static int m=123；”，那就可能会存在一项名称为<strong>ConstantValue的属性</strong>，其值指向常量123</u>。</p>
<p><strong>字段表集合</strong>中不会列出从父类或者父接口中继承而来的字段，但<strong>有可能出现原本Java代码之中不存在的字段</strong>，</p>
<ul>
<li>譬如<strong>在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段</strong>。</li>
<li>另外，在Java语言中<strong>字段是无法重载</strong>的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是<strong>对于Class文件格式</strong>来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>Class文件存储格式中对方法的描述<strong>与对字段的描述采用了几乎完全一致的方式</strong>，方法表的结构如同字段表一样，依次包括</p>
<ul>
<li>访问标志（access_flags）、</li>
<li>名称索引（name_index）、</li>
<li>描述符索引（descriptor_index）、</li>
<li>属性表集合（attributes）几项，</li>
</ul>
<p>如表6-11所示。这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。 </p>
<p><img src="method-table.png" alt="image-20220410175656771"></p>
<p>因为<strong>volatile关键字和transient关键字不能修饰方法</strong>，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，<strong>synchronized、native、strictfp和abstract关键字可以修饰方法</strong>，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。</p>
<p>对于方法表，所有标志位及其取值可参见表6-12。 </p>
<p><img src="method-access-flag.png" alt="image-20220410180018983"></p>
<p>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但<strong>方法里面的代码去哪里了</strong>？方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在<strong>方法属性表集合</strong>中一个名为<strong>“Code”的属性</strong>里面，<strong>属性表作为Class文件格式中最具扩展性的 一种数据项目</strong>，将在下一节中详细讲解。 </p>
<p><img src="TestClass-method-table.png" alt="image-20220410181138732"></p>
<p>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。</p>
<p>但同样地，有可能会出现由编译器自动添加的方法，最常见的便是<strong>类构造器“&lt;clinit&gt;()”方法</strong>和<strong>实例构造器“&lt;init&gt;()”方法</strong>。</p>
<p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名<a href="%E5%9C%A8%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E7%AC%AC2%E7%89%88%E7%9A%844.4.4%E8%8A%82%E5%8F%8A%E3%80%8AJava%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E3%80%8B%E7%AC%AC3%E7%89%88%E7%9A%848.4.2%E8%8A%82%E4%B8%AD%E5%88%86%E5%88%AB%E9%83%BD%E5%AE%9A%E4%B9%89%E4%BA%86%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E7%89%B9%E5%BE%81%E7%AD%BE%E5%90%8D%E4%BB%A5%E5%8F%8AJava%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E7%89%B9%E5%BE%81%E7%AD%BE%E5%90%8D%EF%BC%8CJ**ava%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95%E7%89%B9%E5%BE%81%E7%AD%BE%E5%90%8D%E5%8F%AA%E5%8C%85%E6%8B%AC%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E3%80%81%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F%E5%8F%8A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B**%EF%BC%8C%E8%80%8C%E5%AD%97%E8%8A%82**%E7%A0%81%E7%9A%84%E7%89%B9%E5%BE%81%E7%AD%BE%E5%90%8D%E8%BF%98%E5%8C%85%E6%8B%AC%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8%E8%A1%A8%EF%BC%8C%E8%AF%B7**%E8%AF%BB%E8%80%85%E6%A0%B9%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AF%AD%E5%A2%83%E6%B3%A8%E6%84%8F%E5%8C%BA%E5%88%86%E3%80%82">^4</a>。</p>
<p><strong>特征签名</strong>是指<strong>一个方法中各个<u>参数</u>在常量池中的字段符号引用的集合</strong>，也正是因为返回值不会包含在特征签名之中，所以<strong>Java语言里面是无法仅仅依靠返回值 的不同来对一个已有方法进行重载的</strong>。</p>
<p>但是<strong>在Class文件格式</strong>之中，特征签名的范围明显要更大一些，<strong>只要描述符不是完全一致的两个方法就可以共存</strong>。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。 </p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p><strong>属性表（attribute_info）</strong>在前面的讲解之中已经出现过数次，</p>
<ul>
<li><strong>Class文件</strong>、</li>
<li><strong>字段表</strong>、</li>
<li><strong>方法表</strong></li>
</ul>
<p>都可以携带自己的属性表集合，以描述某些场景专有的信息。 </p>
<p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，<strong>属性表集合的限制稍微宽松一些</strong>，不再要求各个属性表具有严格顺序，并且<strong>《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性</strong>。</p>
<p>为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应 当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经<strong>增加到29项</strong>，这些属性具体见表6-13。后文中将对这些属性中的关键的、常用的部分进行讲解。 </p>
<p>表6-13 虚拟机规范预定义的属性</p>
<p><img src="attribute-info.png" alt="image-20220410185217586"></p>
<p><img src="attribute-info2.png" alt="image-20220410185346193"></p>
<p>对于每一个属性，它的<strong>名称</strong>都要<strong>从常量池中引用一个CONSTANT_Utf8_info类型的常量</strong>来表示，而<strong>属性值的结构则是完全自定义的</strong>，只需要通过一个<strong>u4的长度属性</strong>去说明属性值所占用的位数即可。</p>
<p>一个符合规则的属性表应该满足表6-14中所定义的结构。</p>
<p><img src="attribute-table.png" alt="image-20220410191110419"></p>
<h4 id="1-Code属性-★★★"><a href="#1-Code属性-★★★" class="headerlink" title="1.Code属性 (★★★)"></a>1.Code属性 (★★★)</h4><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在<strong>Code属性</strong>内。 </p>
<p><strong>Code属性</strong>出现在<strong>方法表的属性集合</strong>之中，但<strong>并非所有的方法表都必须存在这个属性</strong>，譬如<strong>接口或者抽象类中的方法就不存在Code属性</strong>，如果方法表有Code属性存在，那么它的结构将如表6-15所示。 </p>
<p><img src="attribute-Code-table.png" alt="image-20220410191328075"></p>
<h5 id="attribute-name-index-与-attribute-length"><a href="#attribute-name-index-与-attribute-length" class="headerlink" title="attribute_name_index 与 attribute_length"></a>attribute_name_index 与 attribute_length</h5><p><strong>attribute_name_index</strong>是一项指向<strong>CONSTANT_Utf8_info型常量的索引</strong>，此常量值固定为<strong>“Code”</strong>，它<strong>代表了该属性的属性名称</strong>，<strong>attribute_length</strong>指示了<strong>属性值的长度</strong>，由于<strong>属性名称索引与属性长度一共为6个字节</strong>，所以<strong>属性值的长度固定为整个属性表长度减去6个字节</strong>。 </p>
<p><strong>max_stack</strong>代表了<strong>操作数栈（Operand Stack）深度的最大值</strong>。</p>
<ul>
<li>在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配<strong>栈帧（Stack Frame）</strong>中的操作栈深度。</li>
</ul>
<p><strong>max_locals</strong>代表了<strong>局部变量表</strong>所需的存储空间。</p>
<ul>
<li>在这里，<strong>max_locals</strong>的<strong>单位</strong>是<strong>变量槽（Slot）</strong>，<strong>变量槽</strong>是虚拟机为<strong>局部变量</strong>分配内存所使用的<strong>最小单位</strong>。对于byte、char、float、int、short、boolean和 returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而<strong>double和long这两种64位的数据类型则需要两个变量槽来存放。</strong></li>
<li><strong>方法参数</strong>（包括实例方法中的隐藏参数“this”）、<strong>显式异常处理程序的参数</strong>（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、<strong>方法体中定义的局部变量</strong>都需要依赖局部变量表来存放。</li>
</ul>
<blockquote>
<p>注意，并不是在方法中用了多少个局部变量，就把这些局部变量所占变量槽数量之和作为max_locals的值，操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。</p>
<p>Java虚拟机的做法是<strong>将局部变量表中的变量槽进行重用</strong>，<u>当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小</u>。 </p>
</blockquote>
<p><strong>code_length</strong>和<strong>code</strong>用来存储Java源程序<strong>编译后生成的字节码指令</strong>。</p>
<ul>
<li><strong>code_length</strong>代表<strong>字节码长度</strong>，<strong>code是用于存储字节码指令的一系列字节流</strong>。</li>
<li>既然叫<strong>字节码指令</strong>，那顾名思义<strong>每个指令就是一个u1类型的单字节</strong>，当<strong>虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析</strong>。</li>
</ul>
<p>我们知道一个<strong>u1数据类型的取值范围为0x00～0xFF</strong>，对应十进制的0～255，也就是一共可以表达256条指令。目前，《Java虚拟机规范》已经定义了其中约200条编码值对应的指令含义，编码与指令之间的对应关系可查阅本书的附录C“虚拟机字节码指令表[^directive]”。</p>
<p>关于<strong>code_length</strong>，有一件值得注意的事情，虽然它是一个<strong>u4类型的长度值</strong>，理论上最大值可以达到2的32次幂，<strong>但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令</strong>，即<strong>它实际只使用了u2的长度</strong>，<strong>如果超过这个限制，Javac编译器就会拒绝编译</strong>。</p>
<ul>
<li><p>一般来讲，编写Java代码时只要不是刻意去编写一个超级长的方法来为难编译器，是不太可能超过这个最大值的限制的。</p>
</li>
<li><p>但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就有可能因为方法生成字节码超长的原因而导致编译失败。 </p>
</li>
</ul>
<p><strong>Code属性</strong>是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为</p>
<ul>
<li><strong>代码</strong>（Code，方法体里面的Java代码）和</li>
<li><strong>元数据</strong>（Metadata，包括类、字段、方法定义及其他信息）两部分，</li>
</ul>
<p>那么在整个Class文件里，<strong>Code属性用于描述代码</strong>，<strong>所有的其他数据项目都用于描述元数据</strong>。</p>
<p>如图6-10所示，这是上一节分析过的实<strong>例构造器“&lt;init&gt;()”方法的Code属性</strong>。它的操作数栈的最大深度和本地变量表的容量都为0x0001，字节码区域所占空间的长度为0x0005。虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并根据字节码指令表翻译出所对应的字节码指令。翻译“2A B7000A B1”的过程为：</p>
<p>图6-10 Code属性结构实例 </p>
<p><img src="TestClass-attribute-Code.png" alt="image-20220410194509861"> </p>
<ol>
<li>读入<strong>2A</strong>，查表得<strong>0x2A</strong>对应的指令为<strong>aload_0</strong>，这个指令的含义是将第0个变量槽中为reference类型的本地变量推送到操作数栈顶。 </li>
<li>读入<strong>B7</strong>，查表得<strong>0xB7</strong>对应的指令为<strong>invokespecial</strong>，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它的父类的方法。这个方法有一个<strong>u2类型的参数说明</strong>具体调用哪一个方法，它<strong>指向常量池</strong>中的一个<strong>CONSTANT_Methodref_info类型常量</strong>，即此方法的<strong>符号引用</strong>。 </li>
<li>读入<strong>000A</strong>，这是<strong>invokespecial指令</strong>的参数，代表一个<strong>符号引用</strong>，查<strong>常量池得0x000A对应的常量为实例构造器“&lt;init&gt;()”方法的符号引用</strong>。</li>
<li>读入<strong>B1</strong>，查表得<strong>0xB1</strong>对应的指令为<strong>return</strong>，含义是从方法的返回，并且返回值为void。这条指令执行后，当前方法正常结束。</li>
</ol>
<p>代码清单6-4 用Javap命令计算字节码指令 （部分）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#3 = Class              #4             // java/lang/Object</span><br><span class="line">#4 = Utf8               java/lang/Object</span><br><span class="line">#5 = Utf8               m</span><br><span class="line">#6 = Utf8               I</span><br><span class="line">#7 = Utf8               &lt;init&gt;</span><br><span class="line">#8 = Utf8               ()V</span><br><span class="line">#9 = Utf8               Code</span><br><span class="line">#10 = Methodref          #3.#11         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#11 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public com.dw.six_class_structure.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/dw/six_class_structure/TestClass;</span><br><span class="line"></span><br><span class="line">  public int inc();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #18                 // Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  this   Lcom/dw/six_class_structure/TestClass;</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<p>这段字节码虽然很短，但我们可以从中看出它<strong>执行过程中的数据交换、方法调用等操作都是基于 栈（操作数栈）</strong>的。</p>
<ul>
<li><p><strong>Java虚拟机执行字节码应该是基于栈的体系结构</strong>。</p>
</li>
<li><p><strong>某些指令（如invokespecial）后面还会带有参数。</strong></p>
</li>
</ul>
<p>在Code属性，实例构造器&lt;init&gt;()和inc()，这两个方法很明显都是没有参数的，<strong>为什么Args_size会为1</strong>？</p>
<p>而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那<strong>Locals又为什么会等于1</strong>？</p>
<ul>
<li>Java语言里面的潜规则：<strong>在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。</strong></li>
<li>这个访问机制对Java程序的编写很重要，而它的实现非常简单，仅仅是通过<strong>在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问</strong>，然后<strong>在虚拟机调用实例方法时自动传入此参数</strong>而已。</li>
<li>因此<strong>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量</strong>，<strong>局部变量表中也会预留出第一个变量槽位来存放对象实例的引用</strong>，所以<strong>实例方法参数值从1开始计算</strong>。</li>
<li>这个处理<strong>只对实例方法</strong>有效，如果代码清单6-1中的inc()方法被声明为static，那Args_size就不会等于1而是等于0了。 </li>
</ul>
<h5 id="显式异常处理表"><a href="#显式异常处理表" class="headerlink" title="显式异常处理表"></a>显式异常处理表</h5><p>异常表对于Code 属性来说并不是必须存在的，如代码清单6-4中就没有异常表生成。 </p>
<p>如果存在异常表，那它的格式应如表6-16所示，包含四个字段，这些字段的含义为：</p>
<ul>
<li>如果当字节码从第<strong>start_pc</strong>行（此处字节码的“行”是一种形象的描述，指的是<strong>字节码相对于方法体开始的偏移量</strong>，而不是Java源码的行号，下同。）到第<strong>end_pc</strong>行之间（不含第end_pc行）出现了类型为<strong>catch_type</strong>或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第<strong>handler_pc</strong>行继续处理。</li>
<li><strong>当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理</strong>。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            0     4     8   Class java/lang/Exception</span><br><span class="line">            0     4    17   any</span><br><span class="line">            8    13    17   any</span><br><span class="line">           17    19    17   any</span><br></pre></td></tr></table></figure>



<p><img src="attribute-Code-exceptions.png" alt="image-20220410205004924"></p>
<p>异常表实际上是Java代码的一部分，尽管字节码中有最初为处理异常而设计的跳转指令，但《Java 虚拟机规范》中明确要求Java语言的编译器应当选择使用异常表而不是通过跳转指令来实现Java异常及finally处理机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc2</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="type">int</span> x; </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			x = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">return</span> x; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			x = <span class="number">2</span>; </span><br><span class="line">            <span class="keyword">return</span> x; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			x = <span class="number">3</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的字节码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public int inc2();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=5, args_size=1</span><br><span class="line">         0: iconst_1	// try块中的x=1</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: iload_1		// 保存x到returnValue中，此时x=1</span><br><span class="line">         3: istore_2</span><br><span class="line">         4: iconst_3	// finaly块中的x=3</span><br><span class="line">         5: istore_1</span><br><span class="line">         6: iload_2 	// 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">         7: ireturn</span><br><span class="line">         8: astore_2	//给catch中定义的Exception e赋值，存储在变量槽 2中</span><br><span class="line">         9: iconst_2	// catch块中的x=2</span><br><span class="line">        10: istore_1</span><br><span class="line">        11: iload_1		// 保存x到returnValue中，此时x=2</span><br><span class="line">        12: istore_3</span><br><span class="line">        13: iconst_3	// finaly块中的x=3</span><br><span class="line">        14: istore_1</span><br><span class="line">        15: iload_3		// 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">        16: ireturn</span><br><span class="line">        17: astore        4		// 如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</span><br><span class="line">        19: iconst_3		// finaly块中的x=3</span><br><span class="line">        20: istore_1</span><br><span class="line">        21: aload         4		// 将异常放置到栈顶，并抛出</span><br><span class="line">        23: athrow</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             0     4     8   Class java/lang/Exception</span><br><span class="line">             0     4    17   any</span><br><span class="line">             8    13    17   any</span><br><span class="line">            17    19    17   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 14: 0</span><br><span class="line">        line 20: 4</span><br><span class="line">        line 14: 6</span><br><span class="line">        line 16: 8</span><br><span class="line">        line 17: 9</span><br><span class="line">        line 20: 13</span><br><span class="line">        line 17: 15</span><br><span class="line">        line 20: 17</span><br><span class="line">        line 21: 21</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 72 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/Exception ]</span><br><span class="line">        frame_type = 72 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure>

<p>编译器为这段Java源码生成了三条异常表记录，对应三条可能出现的代码执行路径。从Java代码的语义上讲，这三条执行路径分别为： </p>
<ul>
<li>如果try语句块中出现属于Exception或其子类的异常，转到catch语句块处理； </li>
<li>如果try语句块中出现不属于Exception或其子类的异常，转到finally语句块处理； </li>
<li>如果catch语句块中出现任何异常，转到finally语句块处理。 </li>
</ul>
<p>返回到我们上面提出的问题，这段代码的返回值应该是多少？熟悉Java语言的读者应该很容易说出答案：</p>
<ul>
<li>如果没有出现异常，返回值是1；</li>
<li>如果出现了Exception异常，返回值是2；</li>
<li>如果出现了Exception以外的异常，方法非正常退出，没有返回值。</li>
</ul>
<p>分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。 </p>
<p>字节码中第0～3行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副本到最后一个本地变量表的变量槽中（这个变量槽里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为方法返回值使用。</p>
<p>为了讲解方便，笔者给这个变量槽起个名字：<strong>returnValue</strong>）。</p>
<p>如果这时候没有出现异常，则会继续走到第4～7行，将变量x赋值为3，然后将之前保存在returnValue中的整数1读入到操作栈顶，最后ireturn指令会以int形式返回操作栈顶中的值，方法结束。</p>
<p>如果出现了异常，PC寄存器指针转到第8行，第8～16行所做的事情是将2赋值给变量x，然后将变量x此时的值赋给returnValue，最后再将变量x的值改为3。</p>
<p>方法返回前同样将returnValue中保留的整数2读到了操作栈顶。从第19行开始的代码，作用是将变量x的值赋为3，并将栈顶的异常抛出，方法结束。</p>
<h4 id="2-Exceptions属性-（★）"><a href="#2-Exceptions属性-（★）" class="headerlink" title="2.Exceptions属性 （★）"></a>2.Exceptions属性 （★）</h4><p>这里的<strong>Exceptions属性</strong>是<strong>在方法表中与Code属性平级的一项属性</strong>，不要与前面Code属性中的异常处理表搞混。</p>
<p><strong>Exceptions属性的作用</strong>是列举出方法中可能抛出的<strong>受查异常（Checked Excepitons）</strong>，也就是<strong>方法描述时在throws关键字后面列举的异常</strong>。它的结构见表6-17。 </p>
<p><img src="attribute-Exceptions-table.png" alt="image-20220410223518736"></p>
<p>此属性中的<strong>number_of_exceptions项</strong>表示方法可能<strong>抛出number_of_exceptions种受查异常</strong>，每一种受查异常使用一个<strong>exception_index_table项</strong>表示；<strong>exception_index_table</strong>是一个<strong>指向常量池中CONSTANT_Class_info型常量的索引</strong>，代表了该受查异常的类型。 </p>
<h4 id="3-LineNumberTable属性"><a href="#3-LineNumberTable属性" class="headerlink" title="3.LineNumberTable属性"></a>3.LineNumberTable属性</h4><p><strong>LineNumberTable属性</strong>用于<strong>描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系</strong>。</p>
<p>它<strong>并不是运行时必需的属性</strong>，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：lines选项来取消或要求生成这项信息。</p>
<p>如果选择不生成LineNumberTable属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</p>
<p>LineNumberTable属性的结构如表6-18所示。 </p>
<p><img src="attribute-LineNumberTable.png" alt="image-20220410224242918"></p>
<p>line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包含start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。 </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int inc();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br></pre></td></tr></table></figure>



<h4 id="4-LocalVariableTable及LocalVariableTypeTable属性"><a href="#4-LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="4.LocalVariableTable及LocalVariableTypeTable属性"></a>4.LocalVariableTable及LocalVariableTypeTable属性</h4><p><strong>LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系</strong>，它也<strong>不是运行时必需的属性</strong>，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p>
<p>如<strong>果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失</strong>，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
<p>在JDK 5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”——<strong>LocalVariableTypeTable</strong>。这个新增的属性结构与LocalVariableTable非常相似，<strong>仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）</strong>。</p>
<h4 id="5-SourceFile及SourceDebugExtension属性"><a href="#5-SourceFile及SourceDebugExtension属性" class="headerlink" title="5.SourceFile及SourceDebugExtension属性"></a>5.SourceFile及SourceDebugExtension属性</h4><p><strong>SourceFile属性</strong>用于<strong>记录生成这个Class文件的源码文件名称。</strong></p>
<p>这个属性也是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。</p>
<p>在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。</p>
<p>如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p>
<h4 id="6-ConstantValue属性-★"><a href="#6-ConstantValue属性-★" class="headerlink" title="6.ConstantValue属性 (★)"></a>6.ConstantValue属性 (★)</h4><p><strong>ConstantValue属性</strong>的作用是通知虚拟机自动<strong>为静态变量赋值</strong>。</p>
<p><strong>只有被static关键字修饰的变量（类 变量）才可以使用这项属性。</strong></p>
<ul>
<li><p>对非static类型的变量（也就是实例变量）的赋值是在实例构造器&lt;init&gt;()方法中进行的；</p>
</li>
<li><p>而对于<strong>类变量</strong>，则有两种方式可以选择：<strong>在类构造器&lt;clinit&gt;()方法中</strong>或者<strong>使用ConstantValue属性</strong>。</p>
</li>
</ul>
<p>目前Oracle公司实现的Javac编译器的选择是，</p>
<ul>
<li>如果<strong>同时使用final和static来修饰一个变量</strong>（按照习惯，这里称“常量”更贴切），<strong>并且这个变量的数据类型是基本类型或者java.lang.String</strong>的话，就将会生成<strong>ConstantValue属性</strong>来进行初始化；</li>
<li>如果这个变量<strong>没有被final修饰</strong>，或者<strong>并非基本类型及字符串</strong>，则将会选择<strong>在&lt;clinit&gt;()方法中进行初始化</strong>。</li>
</ul>
<p>ConstantValue属性的结构如表6-23所示。 </p>
<p><img src="attribute-ConstantValue.png" alt="image-20220410225858423"></p>
<p>从数据结构中可以看出<strong>ConstantValue属性是一个定长属性</strong>，它的<strong>attribute_length数据项值必须固定为2</strong>。</p>
<p><strong>constantvalue_index数据项</strong>代表了<strong>常量池中一个字面量常量的引用</strong>，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。 </p>
<h4 id="7-InnerClasses属性-★"><a href="#7-InnerClasses属性-★" class="headerlink" title="7.InnerClasses属性 (★)"></a>7.InnerClasses属性 (★)</h4><p><strong>InnerClasses属性用于记录内部类与宿主类之间的关联</strong>。</p>
<p>如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成<strong>InnerClasses属性</strong>。</p>
<p>InnerClasses属性的结构如表6-24所示。</p>
<p><img src="attribute-InnerClasses.png" alt="image-20220410230208726"></p>
<p>数据项<strong>number_of_classes代表需要记录多少个内部类信息</strong>，<strong>每一个内部类的信息都由一个inner_classes_info表进行描述</strong>。</p>
<p>表6-25 inner_classes_info表的结构 </p>
<p><img src="attribute-InnerClass-Info.png" alt="image-20220410230407454"></p>
<p><strong>inner_class_info_index</strong>和<strong>outer_class_info_index</strong>都是<strong>指向常量池中CONSTANT_Class_info型常量的索引</strong>，分别代表了<strong>内部类</strong>和<strong>宿主类的符号引用</strong>。 </p>
<p><strong>inner_name_index</strong>是<strong>指向常量池中CONSTANT_Utf8_info型常量的索引</strong>，代表这个<strong>内部类的名称</strong>，如果是<strong>匿名内部类</strong>，这项值为<strong>0</strong>。</p>
<p><strong>inner_class_access_flags是内部类的访问标志</strong>，类似于类的<strong>access_flags</strong>，它的取值范围如表6-26所示。 </p>
<p>表6-26 inner_class_access_flags标志</p>
<p><img src="attribute-InnerClass-access-flag.png" alt="image-20220410230743770"></p>
<h4 id="8-Deprecated及Synthetic属性"><a href="#8-Deprecated及Synthetic属性" class="headerlink" title="8.Deprecated及Synthetic属性"></a>8.Deprecated及Synthetic属性</h4><p><strong>Deprecated和Synthetic两个属性都属于标志类型的布尔属性</strong>，只存在有和没有的区别，没有属性值的概念。</p>
<p><strong>Deprecated属性</strong>用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</p>
<p><strong>Synthetic属性</strong>代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位。</p>
<p>编译器通过生成一些在源代码中不存在的Synthetic方法、字段甚至是整个类的方式，实现了越权访问（越过private修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法（Bridge Method）。</p>
<p>所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位中的一项，<strong>唯一的例外是实例构造器“&lt;init&gt;()”方法和类构造器“&lt;clinit&gt;()”方法。</strong></p>
<h4 id="9-StackMapTable属性"><a href="#9-StackMapTable属性" class="headerlink" title="9.StackMapTable属性"></a>9.StackMapTable属性</h4><p><strong>StackMapTable属性</strong>在JDK 6增加到Class文件规范之中，它是一个<strong>相当复杂的变长属性</strong>，<strong>位于Code属性的属性表</strong>中。</p>
<p>这个属性会在虚拟机类加载的字节码验证阶段<strong>被新类型检查验证器（Type Checker）使用</strong>（详见第7章字节码验证部分），目的在于<strong>代替以前比较消耗性能的基于数据流分析的类型推导验证器</strong>。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">inc2</span><span class="params">()</span> &#123; </span><br><span class="line">		<span class="type">int</span> x; </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			x = <span class="number">1</span>; </span><br><span class="line">			<span class="keyword">return</span> x; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			x = <span class="number">2</span>; </span><br><span class="line">			<span class="keyword">return</span> x; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			x = <span class="number">3</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StackMapTable: number_of_entries = 2</span><br><span class="line">       frame_type = 72 /* same_locals_1_stack_item */</span><br><span class="line">         stack = [ class java/lang/Exception ]</span><br><span class="line">       frame_type = 72 /* same_locals_1_stack_item */</span><br><span class="line">         stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure>

<p><strong>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame）</strong>，每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示<strong>执行到该字节码时局部变量表和操作数栈的验证类型</strong>。</p>
<p><strong>类型检查验证器</strong>会通过<strong>检查目标方法的局部变量和操作数栈所需要的类型</strong>来确定一段字节码指令是否符合逻辑约束。StackMapTable属性的结构如表6-28所示。 </p>
<p><img src="attribute-Code-StackMapTable.png" alt="image-20220410231540598"></p>
<p><strong>一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</strong></p>
<h4 id="10-Signature属性-★"><a href="#10-Signature属性-★" class="headerlink" title="10.Signature属性 (★)"></a>10.Signature属性 (★)</h4><p><strong>Signature属性</strong>在JDK 5增加到Class文件规范之中，它是一个<strong>可选的定长属性</strong>，可以出现于<strong>类、字段表和方法表结构的属性表</strong>中。</p>
<p>在JDK 5里面大幅增强了Java语言的语法，在此之后，<strong>任何类、接口、初 始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（Parameterized Type），则Signature属性会为它记录泛型签名信息。</strong></p>
<p>之所以要专门使用这样一个属性去记录泛型类型，是因为<strong>Java语言的泛型采用的是擦除法实现的伪泛型</strong>，<strong>字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</strong></p>
<ul>
<li><p>使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。</p>
</li>
<li><p>但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。</p>
</li>
</ul>
<p>Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。</p>
<p>Signature属性的结构如表6-29所示。 </p>
<p><img src="attribute-Signature.png" alt="image-20220410232000948"></p>
<p>其中<strong>signature_index项</strong>的值必须是一个对<strong>常量池的有效索引</strong>。<strong>常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名或方法类型签名或字段类型签名</strong>。</p>
<ul>
<li><p>如果当前的Signature属性是类文件的属性，则这个结构表示类签名，</p>
</li>
<li><p>如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，</p>
</li>
<li><p>如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。 </p>
</li>
</ul>
<h4 id="11-BootstrapMethods属性-★"><a href="#11-BootstrapMethods属性-★" class="headerlink" title="11.BootstrapMethods属性(★)"></a>11.BootstrapMethods属性(★)</h4><p><strong>BootstrapMethods属性</strong>在JDK 7时增加到Class文件规范之中，它是一个<strong>复杂的变长属性</strong>，位于<strong>类文件的属性表</strong>中。</p>
<p><strong>这个属性用于保存invokedynamic指令引用的引导方法限定符。</strong></p>
<p>根据《Java虚拟机规范》（从Java SE 7版起）的规定，<strong>如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性</strong>，另外，<strong>即使CONSTANT_InvokeDynamic_info类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性</strong>。</p>
<p><strong>BootstrapMethods属性</strong>和JSR-292中的<strong>InvokeDynamic指令</strong>和<strong>java.lang.Invoke包</strong>关系非常密切。（<strong>InovkeDynamic指令</strong>的运作原理，将在第8章专门花一整节篇幅去介绍它们）</p>
<p>直到 JDK 8中Lambda表达式和接口默认方法的出现，<strong>InvokeDynamic指令</strong>才算在Java语言生成的Class文件中有了用武之地。</p>
<p>BootstrapMethods属性的结构如表6-30所示。</p>
<p><img src="attribute-BoostrapMethods.png" alt="image-20220410232550533"></p>
<p>其中引用到的bootstrap_method结构如表6-31所示。</p>
<p><img src="attribute-BootstrapMethods-bootstrap_method.png" alt="image-20220410232727417"></p>
<p><strong>BootstrapMethods属性</strong>里，<strong>num_bootstrap_methods项的值给出了bootstrap_methods[]数组中的引导方法限定符的数量</strong>。</p>
<p>而bootstrap_methods[]数组的每个成员包含了一个指向<strong>常量池CONSTANT_MethodHandle结构的索引值</strong>，它代表了一个<strong>引导方法</strong>。还包含了这个<strong>引导方法静态参数的序列</strong>（可能为空）。</p>
<p>bootstrap_methods[]数组的每个成员必须包含以下三项内容： </p>
<ul>
<li><p><strong>bootstrap_method_ref</strong>：bootstrap_method_ref项的值必须是一个<strong>对常量池的有效索引</strong>。常量池在该索引处的值必须是一个<strong>CONSTANT_MethodHandle_info结构</strong>。 </p>
</li>
<li><p><strong>num_bootstrap_arguments</strong>：num_bootstrap_arguments项的值给出了<strong>bootstrap_arguments[]数组成员的数量</strong>。</p>
</li>
<li><p>bootstrap_arguments[]：bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效索引。</p>
<ul>
<li>常量池在该索引出必须是下列结构之一：CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、<strong>CONSTANT_MethodHandle_info</strong>或<strong>CONSTANT_MethodType_info</strong>。 </li>
</ul>
</li>
</ul>
<h4 id="12-MethodParameters属性"><a href="#12-MethodParameters属性" class="headerlink" title="12.MethodParameters属性"></a>12.MethodParameters属性</h4><p>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个<strong>用在方法表中的变长属性</strong>。 </p>
<p><strong>MethodParameters的作用是记录方法的各个形参名称和信息。</strong> </p>
<p><strong>MethodParameters是方法表的属性，与Code属性平级的，可以运行时通过反射API获取。</strong></p>
<h4 id="13-模块化相关属性"><a href="#13-模块化相关属性" class="headerlink" title="13.模块化相关属性"></a>13.模块化相关属性</h4><p><strong>JDK 9</strong>的一个重量级功能是Java的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了<strong>Module、ModulePackages和ModuleMainClass</strong>三个属性用于支持Java模块化相关功能。 </p>
<p><strong>Module属性</strong>是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容。</p>
<h4 id="14-运行时注解相关属性"><a href="#14-运行时注解相关属性" class="headerlink" title="14.运行时注解相关属性"></a>14.运行时注解相关属性</h4><p>早在JDK 5时期，Java语言的语法进行了多项增强，其中之一是提供了对注解（Annotation）的支 持。为了存储源码中注解信息，Class文件同步增加了</p>
<ul>
<li>RuntimeVisibleAnnotations、 </li>
<li>RuntimeInvisibleAnnotations、</li>
<li>RuntimeVisibleParameterAnnotations</li>
<li>和RuntimeInvisibleParameterAnnotations四个属性。</li>
</ul>
<p>到了JDK 8时期，进一步加强了Java语言的注解使用范围，又新增类型注解（JSR 308），所以Class文件中也同步增加了</p>
<ul>
<li>RuntimeVisibleTypeAnnotations和</li>
<li>RuntimeInvisibleTypeAnnotations两个属性。</li>
</ul>
<h3 id="6-4-字节码指令简介"><a href="#6-4-字节码指令简介" class="headerlink" title="6.4 字节码指令简介"></a>6.4 字节码指令简介</h3><p><strong>Java虚拟机的指令</strong>由一个</p>
<ul>
<li><strong>字节长度的、代表着某种特定操作含义的数字</strong>（称为<strong>操作码，Opcode</strong>）以及</li>
<li><strong>跟随其后的零至多个代表此操作所需的参数</strong>（称为<strong>操作数，Operand</strong>）构成。</li>
</ul>
<p>由于Java虚拟机采用<strong>面向操作数栈</strong>而不是面向寄存器的架构（这两种架构的执行过程、区别和影响将在第8章中探讨），所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。 </p>
<p><strong>字节码指令集</strong>可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于<strong>限制了Java虚拟机操作码的长度为一个字节（即0～255）</strong>，这意味着<strong>指令集的操作码总数不能够超过256条</strong>；</p>
<p>又由于 Class文件格式<strong>放弃了编译后代码的操作数长度对齐</strong>，这就意味着<strong>虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构</strong>，譬如要将一个16位长度的无符号整数使用两个无符号字节存储起来（假设将它们命名为byte1和byte2），那它们的值应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(byte1 &lt;&lt; <span class="number">8</span>) | byte2</span><br></pre></td></tr></table></figure>

<p>这种操作在某种程度上会导致解释执行字节码时将损失一些性能，但这样做的优势也同样明显：</p>
<ul>
<li>放弃了操作数长度对齐[^5]，就意味着可以省略掉大量的填充和间隔符号；</li>
<li>用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。</li>
</ul>
<p>[^5]: 字节码指令流基本上都是单字节对齐的，只有“tableswitch”和“lookupswitch”两条指令例外，由于它 们的操作数比较特殊，是以4字节为界划分开的，所以这两条指令也需要预留出相应的空位填充来实现对齐。</p>
<h4 id="6-4-1-字节码与数据类型"><a href="#6-4-1-字节码与数据类型" class="headerlink" title="6.4.1 字节码与数据类型"></a>6.4.1 字节码与数据类型</h4><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。</p>
<p>举个例子，</p>
<ul>
<li>iload指令用于从局部变量表中加载int型的数据到操作数栈中，</li>
<li>而fload指令加载的则是float类型的数据。</li>
</ul>
<p>这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。 </p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p>
<ul>
<li><strong>i代表对int类型的数据操作</strong>，</li>
<li><strong>l代表long，</strong></li>
<li><strong>s代表short，</strong></li>
<li><strong>b代表byte，</strong></li>
<li><strong>c代表char，</strong></li>
<li><strong>f代表float，</strong></li>
<li><strong>d代表double，</strong></li>
<li><strong>a代表reference</strong>。</li>
</ul>
<p>也有一些指令的助记符中没有明确指明操作类型的字母，例如</p>
<ul>
<li><p><strong>arraylength指令</strong>，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</p>
</li>
<li><p>还有另外一些指令，例如<strong>无条件跳转指令goto</strong>则是与数据类型无关的指令。</p>
</li>
</ul>
<p>因为Java虚拟机的操作码长度只有一字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么指令的数量恐怕就会超出一字节所能表示的数量范围了。因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，<strong>指令集将会被故意设计成非完全独立的。</strong> </p>
<ul>
<li>并非每种数据类型和每一种操作都有对应的指令；</li>
<li>有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</li>
</ul>
<p>表6-40列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。</p>
<p>表6-40 Java虚拟机指令集所支持的数据类型</p>
<p><img src="bytecode-opcode.png" alt="image-20220411001022147"></p>
<p><img src="bytecode-opcode2.png" alt="image-20220411001118410"></p>
<p>如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。</p>
<p>例如load指令有操作int类型的iload，但是没有操作byte类型的同类指令。 </p>
<p>请注意，从表6-40中看来，<strong>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型</strong>。<strong>编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为 相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据</strong>。</p>
<p>与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，<strong>大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的</strong>。</p>
<h4 id="6-4-2-加载和存储指令"><a href="#6-4-2-加载和存储指令" class="headerlink" title="6.4.2 加载和存储指令"></a>6.4.2 加载和存储指令</h4><p><strong>加载和存储指令</strong>用于<strong>将数据在<u>栈帧</u>中的<u>局部变量表和操作数栈</u><strong>（见第2章关于内存区域的介绍）</strong>之间来回传输</strong>，这类指令包括：</p>
<ul>
<li><p>将一个局部变量加载到操作栈：iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、 dload_&lt;n&gt;、aload、aload_&lt;n&gt; </p>
</li>
<li><p>将一个数值从操作数栈存储到局部变量表：istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、 fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt; </p>
</li>
<li><p>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt; </p>
</li>
<li><p>扩充局部变量表的访问索引的指令：wide</p>
</li>
</ul>
<p><strong>存储数据的操作数栈和局部变量表主要<u>由加载和存储指令</u>进行操作</strong>，除此之外，还有少量指令，<strong>如访问对象的字段或数组元素的指令也会向操作数栈传输数据</strong>。 </p>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_&lt;n&gt;），这些指令助记符实际上代表了一组指令（例如iload_&lt;n&gt;，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。除了这点不同以外，它们的语义与原生的通用指令是完全一致的（例如iload_0的语义与操作数为0时的iload指令语义完全一致）。</p>
<h4 id="6-4-3-运算指令"><a href="#6-4-3-运算指令" class="headerlink" title="6.4.3 运算指令"></a>6.4.3 运算指令</h4><p><strong>算术指令</strong>用于<strong>对两个操作数栈上的值进行某种特定运算</strong>，并<strong>把结果重新存入到操作栈顶</strong>。</p>
<p>运算指令可以分为两种：</p>
<ul>
<li>对<strong>整型数据</strong>进行运算的指令</li>
<li>与对<strong>浮点型数据</strong>进行运算的指令。</li>
</ul>
<p>整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。</p>
<p>不存在直接支持byte、short、char和boolean类型的算术指令，对于上述几种数据的运算，应使用操作<strong>int类型的指令</strong>代替</p>
<ul>
<li><p>加法指令：iadd、ladd、fadd、dadd </p>
</li>
<li><p>减法指令：isub、lsub、fsub、dsub </p>
</li>
<li><p>乘法指令：imul、lmul、fmul、dmul </p>
</li>
<li><p>除法指令：idiv、ldiv、fdiv、ddiv </p>
</li>
<li><p><strong>求余指令</strong>：irem、lrem、frem、drem </p>
</li>
<li><p><strong>取反指令</strong>：ineg、lneg、fneg、dneg </p>
</li>
<li><p><strong>位移指令</strong>：ishl、ishr、iushr、lshl、lshr、lushr </p>
</li>
<li><p><strong>按位或指令</strong>：ior、lor </p>
</li>
<li><p><strong>按位与指令</strong>：iand、land </p>
</li>
<li><p><strong>按位异或指令</strong>：ixor、lxor </p>
</li>
<li><p><strong>局部变量自增指令</strong>：iinc </p>
</li>
<li><p><strong>比较指令</strong>：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</p>
</li>
</ul>
<h4 id="6-4-4-类型转换指令"><a href="#6-4-4-类型转换指令" class="headerlink" title="6.4.4 类型转换指令"></a>6.4.4 类型转换指令</h4><p><strong>类型转换指令可以将两种不同的数值类型相互转换</strong>，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一 一对应的问题。</p>
<p>Java虚拟机直接支持（即<strong>转换时无须显式的转换指令</strong>）以下数值类型的<strong>宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）</strong>：</p>
<ul>
<li><p>int类型到long、float或者double类型 </p>
</li>
<li><p>long类型到float、double类型 </p>
</li>
<li><p>float类型到double类型 </p>
</li>
</ul>
<p>与之相对的，处理<strong>窄化类型转换（Narrowing Numeric Conversion）</strong>时，就必须<strong>显式地使用转换指令来完成</strong>，这些转换指令包括<strong>i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f</strong>。</p>
<p><strong>窄化类型转换</strong>可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p>
<p>在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。</p>
<p><strong>因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N字节的首位了。</strong></p>
<h4 id="6-4-5-对象创建与访问指令"><a href="#6-4-5-对象创建与访问指令" class="headerlink" title="6.4.5 对象创建与访问指令"></a>6.4.5 对象创建与访问指令</h4><p>虽然<strong>类实例和数组都是对象</strong>，但<strong>Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令</strong>（在下一章会讲到数组和普通类的类型创建过程是不同的）。</p>
<p>对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括： </p>
<ul>
<li><p>创建类实例的指令：new </p>
</li>
<li><p>创建数组的指令：newarray、<strong>anewarray</strong>、<strong>multianewarray</strong> </p>
</li>
<li><p><strong>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令</strong>：<strong>getfield、putfield、getstatic、putstatic</strong> </p>
</li>
<li><p><strong>把一个数组元素加载到操作数栈的指令</strong>：<strong>baload、caload、saload、iaload、laload、faload、daload、aaload</strong> </p>
</li>
<li><p><strong>将一个操作数栈的值储存到数组元素中的指令</strong>：<strong>bastore、castore、sastore、iastore、fastore、dastore、aastore</strong> </p>
</li>
<li><p>取数组长度的指令：arraylength </p>
</li>
<li><p>检查类实例类型的指令：instanceof、<strong>checkcast</strong></p>
</li>
</ul>
<h4 id="6-4-6-操作数栈管理指令"><a href="#6-4-6-操作数栈管理指令" class="headerlink" title="6.4.6 操作数栈管理指令"></a>6.4.6 操作数栈管理指令</h4><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括： </p>
<ul>
<li><p>将操作数栈的栈顶一个或两个元素出栈：pop、pop2 </p>
</li>
<li><p><strong>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶</strong>：<strong>dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</strong> </p>
</li>
<li><p>将栈最顶端的两个数值互换：swap</p>
</li>
</ul>
<h4 id="6-4-7-控制转移指令"><a href="#6-4-7-控制转移指令" class="headerlink" title="6.4.7 控制转移指令"></a>6.4.7 控制转移指令</h4><p><strong>控制转移指令</strong>可以让Java虚拟机<strong>有条件或无条件地从指定位置指令</strong>（而不是控制转移指令）<strong>的下一条指令继续执行程序</strong>，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括： </p>
<ul>
<li><p>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne </p>
</li>
<li><p>复合条件分支：<strong>tableswitch</strong>、<strong>lookupswitch</strong> </p>
</li>
<li><p>无条件分支：goto、goto_w、<strong>jsr、jsr_w、ret</strong> </p>
</li>
</ul>
<p>为了可以无须明显标识一个数据的值是否null，也有专门的指令用来检测null值。 </p>
<ul>
<li><p><strong>对于boolean类型、byte类型、char类型和short类型的条件分支比较操作，都使用int类型的比较指令来完成</strong>，</p>
</li>
<li><p>而对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，见6.4.3节），运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。</p>
</li>
</ul>
<p>由于各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便、完善就显得尤为重要，而<strong>Java虚拟机提供的int类型的条件分支指令是最为丰富、强大的</strong>。</p>
<h4 id="6-4-8-方法调用和返回指令"><a href="#6-4-8-方法调用和返回指令" class="headerlink" title="6.4.8 方法调用和返回指令"></a>6.4.8 方法调用和返回指令</h4><p>方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下五条指令用于方法调用： </p>
<ul>
<li><p><strong>invokevirtual指令</strong>：用于<strong>调用对象的实例方法</strong>，根据对象的<strong>实际类型进行分派（虚方法分派）</strong>， 这也是Java语言中最常见的方法分派方式。 </p>
</li>
<li><p><strong>invokeinterface指令</strong>：用于<strong>调用接口方法</strong>，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。 </p>
</li>
<li><p><strong>invokespecial指令</strong>：用于调用一些需要<strong>特殊处理的实例方法</strong>，包括<strong>实例初始化方法、私有方法和父类方法</strong>。 </p>
</li>
<li><p><strong>invokestatic指令</strong>：用于<strong>调用类静态方法（static方法）</strong>。 </p>
</li>
<li><p><strong>invokedynamic指令</strong>：用于在<strong>运行时动态解析出调用点限定符所引用的方法</strong>。并执行该方法。</p>
<ul>
<li>前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而<strong>invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的</strong>。 </li>
</ul>
</li>
</ul>
<p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，</p>
<ul>
<li><p>包括ireturn（当返 回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，</p>
</li>
<li><p>另外还有一条<strong>return指令供声明为void的方法</strong>、<strong>实例初始化方法、类和接口的类初始化方法使用</strong>。</p>
</li>
</ul>
<h4 id="6-4-9-异常处理指令"><a href="#6-4-9-异常处理指令" class="headerlink" title="6.4.9 异常处理指令"></a>6.4.9 异常处理指令</h4><p>在Java程序中显式抛出异常的操作（throw语句）都由<strong>athrow指令</strong>来实现，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。</p>
<p>例如前面介绍整数运算中，当除数为零时，虚拟机会在<strong>idiv或ldiv指令</strong>中抛出<strong>ArithmeticException异常</strong>。 </p>
<p><strong>处理异常（catch语句）不是由字节码指令来实现的， 而是采用<u>异常表</u>来完成。</strong></p>
<h4 id="6-4-10-同步指令"><a href="#6-4-10-同步指令" class="headerlink" title="6.4.10 同步指令"></a>6.4.10 同步指令</h4><p>Java虚拟机可以支持<strong>方法级的同步</strong>和<strong>方法内部一段指令序列的同步</strong>，这两种同步结构都是使用<strong>管程（Monitor，更常见的是直接将它称为“锁”）</strong>来实现的。</p>
<p><strong>方法级的同步是隐式的</strong>，<strong>无须通过字节码指令来控制，它实现在方法调用和返回操作之中</strong>。</p>
<ul>
<li>虚拟机可以从<strong>方法常量池</strong>中的<strong>方法表结构中的ACC_SYNCHRONIZED访问标志</strong>得知一个方法是否被声明为同步方法。<ul>
<li>当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，</li>
<li>如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后<strong>当方法完成（无论是正常完成还是非正常完成）时释放管程</strong>。</li>
</ul>
</li>
<li>在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。<strong>如果一个同步方法执行期间抛出了异常</strong>，并且在<strong>方法内部无法处理此异常</strong>，那<strong>这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放</strong>。 </li>
</ul>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，</p>
<p>譬如有代码清单6-6所示的代码。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onlyMe</span><span class="params">(Foo f)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(f) &#123; </span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，这段代码生成的字节码序列如下： </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Method void onlyMe(Foo) </span><br><span class="line">0 aload<span class="emphasis">_1 // 将对象f入栈 </span></span><br><span class="line"><span class="emphasis">1 dup // 复制栈顶元素（即f的引用） </span></span><br><span class="line"><span class="emphasis">2 astore_</span>2 // 将栈顶元素存储到局部变量表变量槽 2中 </span><br><span class="line">3 monitorenter // 以栈定元素（即f）作为锁，开始同步 </span><br><span class="line">4 aload<span class="emphasis">_0 // 将局部变量槽 0（即this指针）的元素入栈 </span></span><br><span class="line"><span class="emphasis">5 invokevirtual #5 // 调用doSomething()方法 </span></span><br><span class="line"><span class="emphasis">8 aload_</span>2 // 将局部变量Slow 2的元素（即f）入栈 </span><br><span class="line">9 monitorexit // 退出同步 </span><br><span class="line">10 goto 18 // 方法正常结束，跳转到18返回 </span><br><span class="line">13 astore<span class="emphasis">_3 // 从这步开始是异常路径，见下面异常表的Taget 13 </span></span><br><span class="line"><span class="emphasis">14 aload_</span>2 // 将局部变量Slow 2的元素（即f）入栈 </span><br><span class="line">15 monitorexit // 退出同步 </span><br><span class="line">16 aload<span class="emphasis">_3 // 将局部变量Slow 3的元素（即异常对象）入栈 </span></span><br><span class="line"><span class="emphasis">17 athrow // 把异常对象重新抛出给onlyMe()方法的调用者 </span></span><br><span class="line"><span class="emphasis">18 return // 方法正常返回 </span></span><br><span class="line"><span class="emphasis">Exception table: </span></span><br><span class="line"><span class="emphasis">FromTo Target Type </span></span><br><span class="line"><span class="emphasis">  4 	10 	   13 any </span></span><br><span class="line"><span class="emphasis">  13 	16 	   13 any</span></span><br></pre></td></tr></table></figure>

<p>编译器必须确保无论方法通过何种方式完成，<strong>方法中调用过的每条monitorenter指令都必须有其对应的monitorexit指令</strong>，而<strong>无论这个方法是正常结束还是异常结束</strong>。</p>
<p>从代码清单6-6的字节码序列中可以看到，<strong>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</strong></p>
<h3 id="6-5-公有设计，私有实现"><a href="#6-5-公有设计，私有实现" class="headerlink" title="6.5 公有设计，私有实现"></a>6.5 公有设计，私有实现</h3><p>《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：<strong>Class文件格式</strong>以及<strong>字节码指令集</strong>。这些内容与硬件、操作系统和具体的Java虚拟机实现之间是完全独立的。</p>
<p>理解<strong>公有设计与私有实现之间的分界线是非常有必要的</strong>，任何一款Java虚拟机实现都必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。</p>
<p>虚拟机实现的方式主要有以下两种：</p>
<ul>
<li>将输入的Java虚拟机代码在加载时或执行时<strong>翻译成另一种虚拟机的指令集</strong>； </li>
<li>将输入的Java虚拟机代码在加载时或执行时<strong>翻译成宿主机处理程序的本地指令集</strong>（即<strong>即时编译器代码生成技术</strong>）。</li>
</ul>
<h4 id="6-6-Class文件结构的发展"><a href="#6-6-Class文件结构的发展" class="headerlink" title="6.6 Class文件结构的发展"></a>6.6 Class文件结构的发展</h4><p>Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。 </p>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础支柱之一。</p>
<h2 id="字节码指令表"><a href="#字节码指令表" class="headerlink" title="字节码指令表"></a>字节码指令表</h2><p>[^directive]: 附录C 虚拟机字节码指令表</p>
<p><img src="attach-opcode.png" alt="image-20220411011335975"></p>
<p><img src="attach-opcode2.png" alt="image-20220411011436764"></p>
<p><img src="attach-opcode3.png" alt="image-20220411011519668"></p>
<p><img src="attach-opcode4.png" alt="image-20220411011559433"></p>
<p><img src="attach-opcode5.png" alt="image-20220411011635996"></p>
<p><img src="attach-opcode6.png" alt="image-20220411011713309"></p>
<p><img src="attach-opcode7.png" alt="image-20220411011808161"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://dstrive06.github.io">dstrive</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dstrive06.github.io/blog/3856a2b115d7/">https://dstrive06.github.io/blog/3856a2b115d7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dstrive06.github.io" target="_blank">dstrive</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/3df1ad22cf36/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第七章 虚拟机类加载机制</div></div></a></div><div class="next-post pull-right"><a href="/blog/d47b630de3bd/"><img class="next-cover" src="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/327503.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第三章-垃圾收集器与内存分配策略</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dstrive</div><div class="author-info__description">个人博客，记录笔记</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dstrive06"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">记录笔记，记录技术点滴，持续学习...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">第6章 类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%85%B3%E6%80%A7%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-text">无关性的基石</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">Class类文件的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E8%A1%A8%EF%BC%89"><span class="toc-text">class文件数据类型（无符号数和表）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A86-1-Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">表6-1 Class文件格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AD%94%E6%95%B0%E4%B8%8EClass%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-text">魔数与Class文件的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CONSTANT-Class-info%E7%9A%84%E7%BB%93%E6%9E%84%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%EF%BC%8C%E5%A6%82%E8%A1%A86-4%E6%89%80%E7%A4%BA%E3%80%82"><span class="toc-text">CONSTANT_Class_info的结构比较简单，如表6-4所示。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%956-2-%E4%BD%BF%E7%94%A8javap%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E5%B8%B8%E9%87%8F%E8%A1%A8"><span class="toc-text">代码清单6-2 使用javap命令输出常量表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97"><span class="toc-text">访问标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88"><span class="toc-text">类索引、父类索引与接口索引集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text">字段表集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">字段和方法的描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text">方法表集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-text">属性表集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Code%E5%B1%9E%E6%80%A7-%E2%98%85%E2%98%85%E2%98%85"><span class="toc-text">1.Code属性 (★★★)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#attribute-name-index-%E4%B8%8E-attribute-length"><span class="toc-text">attribute_name_index 与 attribute_length</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%A1%A8"><span class="toc-text">显式异常处理表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Exceptions%E5%B1%9E%E6%80%A7-%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-text">2.Exceptions属性 （★）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-LineNumberTable%E5%B1%9E%E6%80%A7"><span class="toc-text">3.LineNumberTable属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-LocalVariableTable%E5%8F%8ALocalVariableTypeTable%E5%B1%9E%E6%80%A7"><span class="toc-text">4.LocalVariableTable及LocalVariableTypeTable属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-SourceFile%E5%8F%8ASourceDebugExtension%E5%B1%9E%E6%80%A7"><span class="toc-text">5.SourceFile及SourceDebugExtension属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-ConstantValue%E5%B1%9E%E6%80%A7-%E2%98%85"><span class="toc-text">6.ConstantValue属性 (★)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-InnerClasses%E5%B1%9E%E6%80%A7-%E2%98%85"><span class="toc-text">7.InnerClasses属性 (★)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Deprecated%E5%8F%8ASynthetic%E5%B1%9E%E6%80%A7"><span class="toc-text">8.Deprecated及Synthetic属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-StackMapTable%E5%B1%9E%E6%80%A7"><span class="toc-text">9.StackMapTable属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Signature%E5%B1%9E%E6%80%A7-%E2%98%85"><span class="toc-text">10.Signature属性 (★)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-BootstrapMethods%E5%B1%9E%E6%80%A7-%E2%98%85"><span class="toc-text">11.BootstrapMethods属性(★)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-MethodParameters%E5%B1%9E%E6%80%A7"><span class="toc-text">12.MethodParameters属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7"><span class="toc-text">13.模块化相关属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7"><span class="toc-text">14.运行时注解相关属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B"><span class="toc-text">6.4 字节码指令简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">6.4.1 字节码与数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.2 加载和存储指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.3 运算指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-4-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.4 类型转换指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.5 对象创建与访问指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-6-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.6 操作数栈管理指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-7-%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.7 控制转移指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-8-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.8 方法调用和返回指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-9-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.9 异常处理指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-10-%E5%90%8C%E6%AD%A5%E6%8C%87%E4%BB%A4"><span class="toc-text">6.4.10 同步指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%85%AC%E6%9C%89%E8%AE%BE%E8%AE%A1%EF%BC%8C%E7%A7%81%E6%9C%89%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.5 公有设计，私有实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-text">6.6 Class文件结构的发展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%8A%82"><span class="toc-text">小节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E8%A1%A8"><span class="toc-text">字节码指令表</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/blog/09209b9f0712/" title="Mybatis执行流程">Mybatis执行流程</a><time datetime="2022-05-18T13:25:33.000Z" title="发表于 2022-05-18 21:25:33">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/1f7ff14317f9/" title="第13章 线程安全与锁优化"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第13章 线程安全与锁优化"/></a><div class="content"><a class="title" href="/blog/1f7ff14317f9/" title="第13章 线程安全与锁优化">第13章 线程安全与锁优化</a><time datetime="2022-05-18T12:58:12.000Z" title="发表于 2022-05-18 20:58:12">2022-05-18</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/blog/5b9a996050a2/" title="第12章 Java内存模型与线程">第12章 Java内存模型与线程</a><time datetime="2022-05-18T12:58:08.000Z" title="发表于 2022-05-18 20:58:08">2022-05-18</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/blog/8c72b87b40d9/" title="第11章 后端编译与优化">第11章 后端编译与优化</a><time datetime="2022-05-18T12:57:36.000Z" title="发表于 2022-05-18 20:57:36">2022-05-18</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/blog/1ee8bf0cee08/" title="第10章 前端编译与优化">第10章 前端编译与优化</a><time datetime="2022-05-18T00:22:06.000Z" title="发表于 2022-05-18 08:22:06">2022-05-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By dstrive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">hello，welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
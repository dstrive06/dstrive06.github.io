<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>第12章 Java内存模型与线程 | dstrive</title><meta name="keywords" content="blog"><meta name="author" content="dstrive"><meta name="copyright" content="dstrive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="并发处理的广泛应用是Amdahl定律代替摩尔定律^1成为计算机性能发展源动力的根本原因，也是人类压榨计算机运算能力的最有力武器。  12.1 概述衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second，TPS）是重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。 服务端的应用是Java语言最擅长的领域之一，这">
<meta property="og:type" content="article">
<meta property="og:title" content="第12章 Java内存模型与线程">
<meta property="og:url" content="https://dstrive06.github.io/blog/5b9a996050a2/index.html">
<meta property="og:site_name" content="dstrive">
<meta property="og:description" content="并发处理的广泛应用是Amdahl定律代替摩尔定律^1成为计算机性能发展源动力的根本原因，也是人类压榨计算机运算能力的最有力武器。  12.1 概述衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second，TPS）是重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。 服务端的应用是Java语言最擅长的领域之一，这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-05-18T12:58:08.000Z">
<meta property="article:modified_time" content="2022-05-18T12:58:08.000Z">
<meta property="article:author" content="dstrive">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dstrive06.github.io/blog/5b9a996050a2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: dstrive","link":"链接: ","source":"来源: dstrive","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第12章 Java内存模型与线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-05-18 20:58:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">dstrive</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第12章 Java内存模型与线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-18T12:58:08.000Z" title="发表于 2022-05-18 20:58:08">2022-05-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-18T12:58:08.000Z" title="更新于 2022-05-18 20:58:08">2022-05-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/">《深入理解Java虚拟机》</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/">第十二章</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第12章 Java内存模型与线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>并发处理的广泛应用是<strong>Amdahl定律</strong>代替摩尔定律<a href="Amdahl%E5%AE%9A%E5%BE%8B%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B9%B6%E8%A1%8C%E5%8C%96%E4%B8%8E%E4%B8%B2%E8%A1%8C%E5%8C%96%E7%9A%84%E6%AF%94%E9%87%8D%E6%9D%A5%E6%8F%8F%E8%BF%B0%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E8%83%BD%E8%8E%B7%E5%BE%97%E7%9A%84%E8%BF%90%E7%AE%97%E5%8A%A0%E9%80%9F%E8%83%BD%E5%8A%9B%EF%BC%8C%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B%E5%88%99%E7%94%A8%E4%BA%8E%E6%8F%8F%E8%BF%B0%E5%A4%84%E7%90%86%E5%99%A8%E6%99%B6%E4%BD%93%E7%AE%A1%E6%95%B0%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%91%E5%B1%95%E5%85%B3%E7%B3%BB%E3%80%82%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%AE%9A%E5%BE%8B%E7%9A%84%E6%9B%B4%E6%9B%BF%E4%BB%A3%E8%A1%A8%E4%BA%86%E8%BF%91%E5%B9%B4%E6%9D%A5%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E4%BB%8E%E8%BF%BD%E6%B1%82%E5%A4%84%E7%90%86%E5%99%A8%E9%A2%91%E7%8E%87%E5%88%B0%E8%BF%BD%E6%B1%82%E5%A4%9A%E6%A0%B8%E5%BF%83%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B%E3%80%82">^1</a>成为计算机性能发展源动力的根本原因，也是人类压榨计算机运算能力的最有力武器。 </p>
<h2 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h2><p>衡量一个服务性能的高低好坏，<strong>每秒事务处理数（Transactions Per Second，TPS）</strong>是重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。</p>
<p>服务端的应用是Java语言最擅长的领域之一，这个领域的应用占了Java应用中最大的一块份额，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持。</p>
<h2 id="12-2-硬件的效率与一致性"><a href="#12-2-硬件的效率与一致性" class="headerlink" title="12.2 硬件的效率与一致性"></a>12.2 硬件的效率与一致性</h2><p>绝大多数的运算任务都不可能只靠处理器“计算”就能完成。</p>
<p><strong>处理器至少要与内存交互</strong>，如读取运算数据、存储运算结果等，这个I/O操作就是很难消除的（无法仅靠寄存器来完成所有运算任务）。</p>
<p>由于<strong>计算机的存储设备与处理器的运算速度有着几个数量级的差距</strong>，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的<strong>高速缓存（Cache）</strong>来作为内存与处理器之间的缓冲：</p>
<ul>
<li>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 </li>
</ul>
<p>基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：<strong>缓存一致性（Cache Coherence）</strong>。</p>
<p>在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），这种系统称为<strong>共享内存</strong> </p>
<p><strong>多核系统（Shared Memory Multiprocessors System）</strong>，如图12-1所示。</p>
<p><img src="Shared-Memory-Multiprocessors-System.png" alt="image-20220508215632265"></p>
<center>图12-1 处理器、高速缓存、主内存间的交互关系</center>

<p>除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）优化</strong>，处理器会在计算之后将乱序执行的结果重组，<strong>保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致</strong>，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。</p>
<p>与处理器的乱序执行优化类似，<strong>Java虚拟机的即时编译器中也有指令重排序（Instruction Reorder）优化</strong>。</p>
<h2 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h2><p>《Java虚拟机规范》[1]中曾试图定义一种<strong>“Java内存模型”（Java Memory Model，JMM）</strong>来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<h3 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h3><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即<strong>关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</strong>。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是<strong>不包括局部变量与方法参数</strong>，因为后者是<strong>线程私有</strong><a href="%E5%A6%82%E6%9E%9C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%80%E4%B8%AAreference%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9C%A8Java%E5%A0%86%E4%B8%AD%E5%8F%AF%E8%A2%AB%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%8C%E4%BD%86%E6%98%AFreference%E6%9C%AC%E8%BA%AB%E5%9C%A8Java%E6%A0%88%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%E3%80%82">^2</a>的，不会被共享，自然就不会存在竞争问题。</p>
<p>Java内存模型规定了所有的变量都存储在<strong>主内存（Main Memory）</strong>中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）。</p>
<p><strong>每条线程还有自己的<u>工作内存（Working Memory</u>，可与前面讲的处理器高速缓存类比）</strong>，线程的工作内存中保存了被该线程使用的变量的<strong>主内存副本</strong>[^3]，<strong>线程对变量的所有操作（读取、赋值等）都必须在<u>工作内存</u>中进行</strong>，而不能直接读写主内存中的数据[^4]。</p>
<p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图12-2所示，注意与图12-1进行对比。 </p>
<p><img src="java-thread-model.png" alt="image-20220508224013891"></p>
<center>图12-2 线程、主内存、工作内存三者的交互关系（请与图12-1对比） </center>



<p><strong>这里所讲的主内存、工作内存与第2章所讲的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分</strong>，这两者基本上是没有任何关系的。如果两者一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分[^5]，而工作内存则对应于虚拟机栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。 </p>
<p>[^3]: 如“假设线程中访问一个10MB大小的对象，也会把 这10MB的内存复制一份出来吗？”，事实上并不会如此，这个对象的引用、对象中某个在线程访问到的字段是有可能被复制的，但不会有虚拟机把整个对象复制一次。<br>[^4]: 根据《Java虚拟机规范》的约定，volatile变量依然有工作内存的拷贝，但是由于它特殊的操作顺序性规定（后文会讲到），所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于volatile<br>[^5]: 除了实例数据，Java堆还保存了对象的其他信息，对于HotSpot虚拟机来讲，有Mark Word（存储对 象哈希码、GC标志、GC年龄、同步锁等信息）、Klass Point（指向存储类型元数据的指针）及一些用于字节对齐补白的填充数据（如果实例数据刚好满足8字节对齐，则可以不存在补白）。</p>
<h3 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下<strong>8种操</strong>作来完成。</p>
<p>Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的；（对于double和long类型的变量来说， load、store、read和write操作在某些平台上允许有例外）</p>
<ul>
<li><p><strong>lock（锁定）</strong>：作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态。 </p>
</li>
<li><p><strong>unlock（解锁）</strong>：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 </p>
</li>
<li><p><strong>read（读取）</strong>：作用于<strong>主内存</strong>的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 </p>
</li>
<li><p><strong>load（载入）</strong>：作用于<strong>工作内存</strong>的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 </p>
</li>
<li><p><strong>use（使用）</strong>：作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 </p>
</li>
<li><p><strong>assign（赋值）</strong>：作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 </p>
</li>
<li><p><strong>store（存储）</strong>：作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 </p>
</li>
<li><p><strong>write（写入）</strong>：作用于<strong>主内存</strong>的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</p>
</li>
</ul>
<p>如果要<strong>把一个变量从主内存拷贝到工作内存</strong>，那就要<strong>按顺序执行read和load操作</strong>，如果要<strong>把变量从工作内存同步回主内存</strong>，就要<strong>按顺序执行store和write操作</strong>。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。</p>
<p>也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。</p>
<p>除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li><p><strong>不允许read和load、store和write操作之一单独出现</strong>，即<strong>不允许一个变量从主内存读取了但工作内存不接受</strong>，或者<strong>工作内存发起回写了但主内存不接受的情况出现</strong>。</p>
</li>
<li><p><strong>不允许一个线程丢弃它最近的assign操作</strong>，即<strong>变量在工作内存中改变了之后必须把该变化同步回主内存</strong>。</p>
</li>
<li><p><strong>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</strong></p>
</li>
<li><p>一个<strong>新的变量只能在主内存中“诞生”</strong>，<strong>不允许在工作内存中直接使用一个<u>未被初始化</u>（load或assign）的变量</strong>，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。 </p>
</li>
<li><p><strong>一个变量在同一个时刻只允许一条线程对其进行lock操作</strong>，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 </p>
</li>
<li><p>如果<strong>对一个变量执行<u>lock操作</u><strong>，那将</strong>会清空<u>工作内存</u>中此变量的值</strong>，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。</p>
</li>
<li><p><strong>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</strong> </p>
</li>
<li><p><strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</strong></p>
</li>
</ul>
<h3 id="12-3-3-对于volatile型变量的特殊规则"><a href="#12-3-3-对于volatile型变量的特殊规则" class="headerlink" title="12.3.3 对于volatile型变量的特殊规则"></a>12.3.3 对于volatile型变量的特殊规则</h3><p><strong>关键字volatile</strong>可以说是<strong>Java虚拟机提供的最轻量级的同步机制</strong>，但是它并不容易被正确、完整地理解，以至于许多程序员都习惯去避免使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。</p>
<p>当一个变量被定义成volatile之后，它将具备两项特性：</p>
<ul>
<li><p>第一项是<strong>保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，<strong>普通变量的值在线程间传递时均需要通过主内存来完成</strong>。</p>
</li>
<li><p>使用volatile变量的第二个语义是<strong>禁止指令重排序优化</strong>，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p>
</li>
</ul>
<h4 id="保证此变量对所有线程的可见性"><a href="#保证此变量对所有线程的可见性" class="headerlink" title="保证此变量对所有线程的可见性"></a>保证此变量对所有线程的可见性</h4><p><strong>volatile变量在各个线程的工作内存中是不存在一致性问题的</strong>（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但<strong>由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题</strong>），但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的，请看代码清单12-1中演示的例子。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，</span></span><br><span class="line"><span class="comment"> * 如果这段代码能够正确并发的话，最后输出的结果应该是200000。 读者运行完这段代码之后，并不会获得期望的结果，而且会</span></span><br><span class="line"><span class="comment"> * 发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。这是为什么呢？</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 问题就出在自增运算“race++”之中，我们用Javap反编译这段代码后会得到如下字节码所示， 发</span></span><br><span class="line"><span class="comment"> * 现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成 （return指令不是由race++产生</span></span><br><span class="line"><span class="comment"> * 的，这条指令可以不计算），从字节码层面上已经很容易分析出并发失败的原因了： 当getstatic指令把</span></span><br><span class="line"><span class="comment"> * race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的， 但是在执行iconst_1、iadd这</span></span><br><span class="line"><span class="comment"> * 些指令的时候，其他线程可能已经把race的值改变了， 而操作栈顶的值就变成了过期的数据，所以</span></span><br><span class="line"><span class="comment"> * putstatic指令执行后就可能把较小的race值同步回主内存之中。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * public static void increase();</span></span><br><span class="line"><span class="comment"> * 		Code:Stack=2, Locals=0, Args_size=0 </span></span><br><span class="line"><span class="comment"> * 			0: getstatic #13; //Field race:I </span></span><br><span class="line"><span class="comment"> * 			3:iconst_1 4: iadd </span></span><br><span class="line"><span class="comment"> * 			5: putstatic #13; //Field race:I </span></span><br><span class="line"><span class="comment"> *			8: return </span></span><br><span class="line"><span class="comment"> *		LineNumberTable:</span></span><br><span class="line"><span class="comment"> * 			line 14: 0 </span></span><br><span class="line"><span class="comment"> * 			line 15: 8</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">race</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">		race++;</span><br><span class="line">	&#125;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREADS_COUNT</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[THREADS_COUNT];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">			threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">						increase();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			threads[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">	   <span class="comment">// 等待所有累加线程都结束 </span></span><br><span class="line">		<span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">			Thread.yield();</span><br><span class="line">		System.out.println(race);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。</strong></p>
<p>由于<strong>volatile变量只能保证可见性</strong>，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性： </p>
<ul>
<li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 </p>
</li>
<li><p>变量不需要与其他的状态变量共同参与不变约束。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">a++; <span class="comment">//不能保证一致性</span></span><br><span class="line">a=<span class="number">1</span>; <span class="comment">//可以保证一致性，因为赋值给a不依赖a之前的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions; </span><br><span class="line"><span class="type">char</span>[] configText; <span class="comment">// 此变量必须定义为volatile </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行 </span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后 </span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用 </span></span><br><span class="line">configOptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>(); </span><br><span class="line">configText = readConfigFile(fileName); </span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行 </span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成 </span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123; </span><br><span class="line">    sleep(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息 </span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>

<p>代码清单12-4中所示的程序是一段伪代码，其中描述的场景是开发中常见配置读取过程，只是我们在处理配置文件时一般不会出现并发，所以没有察觉这会有问题。读者试想一下，<strong>如果定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一条代码“initialized=true”被提前执行</strong>（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这条语句对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。 </p>
<p>代码清单12-5 DCL单例模式 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Singleton.Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那为何说它禁止指令重排序呢？从硬件架构上讲，<strong>指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。</strong>但并不是说指令任意重排，<strong>处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果</strong>。</p>
<p>譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——(A+10)<em>2与A</em>2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证处理器执行后面依赖到A、B值的操作时能获取正确的A和B值即可。所以在同一个处理器中，重排序过的代码看起来依然是有序的。</p>
<p><strong>Java内存模型中对volatile变量定义的特殊规则的定义。</strong>假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则： </p>
<ul>
<li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现。 </li>
</ul>
<p>这条规则要求在工作内存中，每次使用V前都<strong>必须先从主内存刷新最新的值</strong>，用于保证能看见其他线程对变量V所做的修改。 </p>
<ul>
<li>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现。</li>
</ul>
<p>这条规则要求在工作内存中，<strong>每次修改V后都必须立刻同步回主内存中</strong>，用于保证其他线程可以看到自己对变量V所做的修改。 </p>
<ul>
<li>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q。</li>
</ul>
<p>这条规则<strong>要求volatile修饰的变量不会被指令重排序优化</strong>，从而保证代码的执行顺序与程序的顺序相同。</p>
<h3 id="12-3-4-针对long和double型变量的特殊规则"><a href="#12-3-4-针对long和double型变量的特殊规则" class="headerlink" title="12.3.4 针对long和double型变量的特殊规则"></a>12.3.4 针对long和double型变量的特殊规则</h3><h3 id="12-3-5-原子性、可见性与有序性"><a href="#12-3-5-原子性、可见性与有序性" class="headerlink" title="12.3.5 原子性、可见性与有序性"></a>12.3.5 原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理<strong>原子性、可见性和有序性</strong>这三个特征来建立的。</p>
<h4 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1.原子性（Atomicity）"></a>1.原子性（Atomicity）</h4><p>由Java内存模型来直接保证的原子性变量操作包括<strong>read、load、assign、use、store和write</strong>这六个，我们大致可以认为，<strong>基本数据类型的访问、读写都是具备原子性的</strong>。</p>
<p>如果应用场景需要一个更大范围的原子性保证（经常会遇到），<strong>Java内存模型还提供了<u>lock和unlock操作</u>来满足这种需求</strong>，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的<strong>字节码指令monitorenter和monitorexit</strong>来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——<strong>synchronized关键字</strong>，因此<strong>在synchronized块之间的操作也具备原子性</strong>。 </p>
<h4 id="2-可见性（Visibility）"><a href="#2-可见性（Visibility）" class="headerlink" title="2.可见性（Visibility）"></a>2.可见性（Visibility）</h4><p>可见性就是指<strong>当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</strong>。</p>
<p>Java内存模型是通过在变量修改后将新值同步回主内存，<strong>在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的</strong>，无论是普通变量还是volatile变量都是如此。</p>
<p>普通变量与volatile变量的区别是：<strong>volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</strong>。</p>
<p>除了volatile之外，Java还有两个关键字能实现可见性，它们是<strong>synchronized和final</strong>。</p>
<ul>
<li><p><strong>同步块的可见性</strong>是由“<strong>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</strong>”这条规则获得的。</p>
</li>
<li><p>而<strong>final关键字的可见性是指</strong>：被final修饰的字段在构造器中一旦被初始化完成，<strong>并且构造器没有把“this”的引用传递出去</strong>（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</p>
</li>
</ul>
<p>如代码清单12-7所示，变量i与j都具备可见性，它们无须同步就能被其他线程正确访问。 </p>
<p>代码清单12-7 final与可见性 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> i; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> j; </span><br><span class="line"><span class="keyword">static</span> &#123; </span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 省略后续动作 </span></span><br><span class="line">&#125;</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 也可以选择在构造函数中初始化 </span></span><br><span class="line">    j = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 省略后续动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-有序性（Ordering）"><a href="#3-有序性（Ordering）" class="headerlink" title="3.有序性（Ordering）"></a>3.有序性（Ordering）</h4><p>Java程序中天然的有序性可以总结为一句话：</p>
<ul>
<li>如果在<strong>本线程内观察</strong>，<strong>所有的操作都是有序的</strong>；</li>
<li>如果<strong>在一个线程中观察另一个线程</strong>，<strong>所有的操作都是无序的</strong>。</li>
</ul>
<p>前半句是指<strong>“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics）</strong>，后半句是指<strong>“指令重排序”现象和“工作内存与主内存同步延迟”</strong>现象。</p>
<p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，<strong>volatile关键字本身就包含了禁止指令重排序的语义</strong>，而<strong>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的</strong>，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<h3 id="12-3-6-先行发生原则"><a href="#12-3-6-先行发生原则" class="headerlink" title="12.3.6 先行发生原则"></a>12.3.6 先行发生原则</h3><p>这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。</p>
<p>假设线程A中的操作“i=1”先行发生于线程B的操作“j=i”，那我们就可以确定在线程B的操作执行后，变量j的值一定是等于1，得出这个结论的依据有两个：一是根据先行发生原则，“i=1”的结果可以被观察到；二是线程C还没登场，线程A操作结束之后没有其他线程会修改变量i的值。</p>
<p>现在再来考虑线程C，我们依然保持线程A和B之间的先行发生关系，而C出现在线程A和B的操作之间，但是C与B没有先行发生关系，那j的值会是多少呢？答案是不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就存在读取到过期数据的风险，不具备多线程安全性。</p>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。<strong>如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序</strong>。</p>
<ul>
<li><p><strong>程序次序规则（Program Order Rule）</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 </p>
</li>
<li><p><strong>管程锁定规则（Monitor Lock Rule）</strong>：<strong>一个unlock操作先行发生于后面对同一个锁的lock操作</strong>。这里必须强调的是<strong>“同一个锁”</strong>，而“后面”是指时间上的先后。 </p>
</li>
<li><p><strong>volatile变量规则（Volatile Variable Rule）</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</p>
</li>
<li><p><strong>线程启动规则（Thread Start Rule）</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。 </p>
</li>
<li><p><strong>线程终止规则（Thread Termination Rule）</strong>：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</p>
</li>
<li><p><strong>线程中断规则（Thread Interruption Rule）</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。 </p>
</li>
<li><p><strong>对象终结规则（Finalizer Rule）</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 </p>
</li>
<li><p><strong>传递性（Transitivity）</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p>
</li>
</ul>
<p>Java语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些。</p>
<p><strong>一个操作“时间上的先发生”不代表这个操作会是“先行发生”</strong>，时间先后顺序与先行发生原则之间基本没有因果关系。</p>
<h2 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h2><h3 id="12-4-1-线程的实现"><a href="#12-4-1-线程的实现" class="headerlink" title="12.4.1 线程的实现"></a>12.4.1 线程的实现</h3><p><strong>线程是比进程更轻量级的调度执行单位</strong>，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度。</p>
<p>目前线程是Java里面进行处理器资源调度的最基本单位，不过如果日后Loom项目能成功为Java引入纤程（Fiber）的话，可能就会改变这一点。 </p>
<p>主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经调用过<strong>start()方法</strong>且还未结束的<code>java.lang.Thread</code>类的实例就代表着一个线程。我们注意到Thread类与大部分的Java类库API有着显著差别，它的所有关键方法都被声明为Native。在Java类库API中，一个Native方法往往就意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用Native方法，不过通常最高效率的手段也就是平台相关的手段）。</p>
<p>实现线程主要有三种方式：</p>
<ul>
<li><p>使用<strong>内核线程实现</strong>（1：1实现），</p>
</li>
<li><p>使用<strong>用户线程实现</strong>（1：N实现）， </p>
</li>
<li><p>使用<strong>用户线程加轻量级进程混合实现</strong>（N：M实现）。 </p>
</li>
</ul>
<h4 id="1-内核线程实现"><a href="#1-内核线程实现" class="headerlink" title="1.内核线程实现"></a>1.内核线程实现</h4><p>使用内核线程实现的方式也被称为1：1实现。<strong>内核线程（Kernel-Level Thread，KLT）</strong>就是<strong>直接由操作系统内核（Kernel，下称内核）支持的线程</strong>，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>
<p><strong>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情</strong>，支持多线程的内核就称为多线程内核（Multi-Threads Kernel）。 </p>
<p>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——<strong>轻量级进程（Light Weight Process，LWP）</strong>，<strong>轻量级进程就是我们通常意义上所讲的线程</strong>，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型，如图12-3所示。</p>
<p><img src="lwp-thread-model.png" alt="image-20220510203545115"></p>
<center>图12-3 轻量级进程与内核线程之间1：1的关系 </center>

<p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。</p>
<p>轻量级进程也具有它的<strong>局限性</strong>：</p>
<ul>
<li><p>首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而<strong>系统调用的代价相对较高</strong>，<strong>需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换</strong>。</p>
</li>
<li><p>其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</p>
</li>
</ul>
<h4 id="2-用户线程实现"><a href="#2-用户线程实现" class="headerlink" title="2.用户线程实现"></a>2.用户线程实现</h4><p>使用<strong>用户线程</strong>实现的方式被称为<strong>1：N实现</strong>。</p>
<p><strong>广义上</strong>来讲，<strong>一个线程只要不是内核线程，都可以认 为是用户线程（User Thread，UT）的一种</strong>，因此从这个定义上看，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受到限制，并不具备通常意义上的用户线程的优点。</p>
<p>而<strong>狭义上</strong>的用户线程指的是完全建立在用户空间的线程库上，<strong>系统内核不能感知到用户线程的存在及如何实现的</strong>。**用户线程的建立、同步、销毁和调度<u>完全在用户态中完成</u>**，不需要内核的帮助。</p>
<p>如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型，如图12-4所示。</p>
<p><img src="user-thread-model.png" alt="image-20220510203908637"></p>
<center>图12-4 进程与用户线程之间1：N的关系 </center>

<p>用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。</p>
<p>一般的应用程序都不倾向使用用户线程。</p>
<p>但是近年来许多新的、以高并发为卖点的编程语言又普遍支持了用户线程，譬如<strong>Golang、Erlang</strong>等，使得用户线程的使用率有所回升。</p>
<h4 id="3-混合实现"><a href="#3-混合实现" class="headerlink" title="3.混合实现"></a>3.混合实现</h4><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种<strong>将内核线程与用户线程一起使用的实现方式</strong>，被称为<strong>N：M实现</strong>。</p>
<p>既存在用户线程，也存在轻量级进程。</p>
<p>用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是N：M的关系，如图12-5所示，这种就是多对多的线程模型。</p>
<p><img src="mixed-thread-model.png" alt="image-20220510205123880"></p>
<p>许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了M：N的线程模型实现。在这些操作系统上的应用也相对更容易应用M：N的线程模型。 </p>
<h4 id="4-Java线程的实现"><a href="#4-Java线程的实现" class="headerlink" title="4.Java线程的实现"></a>4.Java线程的实现</h4><p>从JDK 1.3起，“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为<strong>基于操作系统原生线程模型来实现</strong>，即<strong>采用1：1的线程模型</strong>。 </p>
<p>以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），<strong>全权交给底下的操作系统去处理</strong>，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，<strong>都是由操作系统完成的</strong>，也<strong>都是由操作系统全权决定的</strong>。</p>
<h3 id="12-4-2-Java线程调度"><a href="#12-4-2-Java线程调度" class="headerlink" title="12.4.2 Java线程调度"></a>12.4.2 Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是<strong>协同式（Cooperative Threads-Scheduling）线程调度</strong>和<strong>抢占式（Preemptive Threads-Scheduling）线程调度</strong>。 </p>
<h4 id="协同式调度的多线程系统"><a href="#协同式调度的多线程系统" class="headerlink" title="协同式调度的多线程系统"></a>协同式调度的多线程系统</h4><p><strong>线程的执行时间由线程本身来控制</strong>，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。</p>
<ul>
<li>协同式多线程的最大好处是<strong>实现简单</strong>，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题。</li>
<li>它的坏处也很明显：<strong>线程执行时间不可控制</strong>，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</li>
</ul>
<h4 id="抢占式调度的多线程系统"><a href="#抢占式调度的多线程系统" class="headerlink" title="抢占式调度的多线程系统"></a>抢占式调度的多线程系统</h4><p><strong>每个线程将由系统来分配执行时间</strong>，线程的切换不由线程本身来决定。</p>
<p>可以通过<strong>优先级</strong>“建议”操作系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点。线程优先级并不是一项稳定的调节手段，线程调度最终还是由操作系统说了算。</p>
<p>Java使用的线程调度方式就是抢占式调度。</p>
<h3 id="12-4-3-状态转换"><a href="#12-4-3-状态转换" class="headerlink" title="12.4.3 状态转换"></a>12.4.3 状态转换</h3><p>Java语言定义了<strong>6种线程状态</strong>，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是：</p>
<ul>
<li><p><strong>新建（New）</strong>：创建后尚未启动的线程处于这种状态。 </p>
</li>
<li><p><strong>运行（Runnable）</strong>：包括操作系统线程状态中的<strong>Running和Ready</strong>，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。 </p>
</li>
<li><p><strong>无限期等待（Waiting）</strong>：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态： </p>
<ul>
<li><p>没有设置Timeout参数的Object::wait()方法；     </p>
</li>
<li><p>没有设置Timeout参数的Thread::join()方法； </p>
</li>
<li><p>LockSupport::park()方法。 </p>
</li>
</ul>
</li>
<li><p><strong>限期等待（Timed Waiting）</strong>：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p>
<ul>
<li><p>Thread::sleep()方法； </p>
</li>
<li><p>设置了Timeout参数的Object::wait()方法； </p>
</li>
<li><p>设置了Timeout参数的Thread::join()方法； </p>
</li>
<li><p>LockSupport::parkNanos()方法； </p>
</li>
<li><p>LockSupport::parkUntil()方法。 </p>
</li>
</ul>
</li>
<li><p><strong>阻塞（Blocked）</strong>：线程被阻塞了，<strong>“阻塞状态”与“等待状态”的区别</strong>是<strong>“阻塞状态”在等待着获取到一个排它锁</strong>，这个事件将在另外一个线程放弃这个锁的时候发生；而<strong>“等待状态”则是在等待一段时间，或者唤醒动作的发生</strong>。在程序等待进入同步区域的时候，线程将进入这种（阻塞）状态。 </p>
</li>
<li><p><strong>结束（Terminated）</strong>：已终止线程的线程状态，线程已经结束执行。</p>
</li>
</ul>
<p>上述6种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如图12-6所示。</p>
<p><img src="thread-status-swith.png" alt="image-20220510213426117"></p>
<center>图12-6 线程状态转换关系</center>



<h2 id="12-5-Java与协程"><a href="#12-5-Java与协程" class="headerlink" title="12.5 Java与协程"></a>12.5 Java与协程</h2><h3 id="12-5-1-内核线程的局限"><a href="#12-5-1-内核线程的局限" class="headerlink" title="12.5.1 内核线程的局限"></a>12.5.1 内核线程的局限</h3><p>内核线程的调度成本主要来自于<strong>用户态与核心态之间的状态转换</strong>，而这两种状态转换的开销主要来自于<strong>响应中断</strong>、<strong>保护和恢复执行现场的成本</strong>。</p>
<h3 id="12-5-2-协程的复苏"><a href="#12-5-2-协程的复苏" class="headerlink" title="12.5.2 协程的复苏"></a>12.5.2 协程的复苏</h3><p>由于最初多数的<strong>用户线程</strong>是被设计成<strong>协同式调度（Cooperative Scheduling）</strong>的，所以它有了一个别名——<strong>“协程”（Coroutine）</strong>。</p>
<p><strong>协程的主要优势是轻量</strong>，无论是<strong>有栈协程</strong>还是<strong>无栈协程</strong>，都要比传统内核线程要轻量得多。</p>
<ul>
<li><strong>有栈协程</strong>：会完整地做<strong>调用栈的保护、恢复工作</strong>。</li>
<li><strong>无栈协程</strong>：本质上是一种<strong>有限状态机</strong>，<strong>状态保存在<u>闭包</u>里</strong>，自然比有栈协程恢复调用栈要轻量得多，但功能也相对更有限。</li>
</ul>
<h4 id="12-5-3-Java的解决方案"><a href="#12-5-3-Java的解决方案" class="headerlink" title="12.5.3 Java的解决方案"></a>12.5.3 Java的解决方案</h4><p>纤程（Fiber）,它就是一种典型的<strong>有栈协程</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://dstrive06.github.io">dstrive</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dstrive06.github.io/blog/5b9a996050a2/">https://dstrive06.github.io/blog/5b9a996050a2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dstrive06.github.io" target="_blank">dstrive</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/1f7ff14317f9/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第13章 线程安全与锁优化</div></div></a></div><div class="next-post pull-right"><a href="/blog/8c72b87b40d9/"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第11章 后端编译与优化</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://backiee.com/static/wpdb/wallpapers/v2/1000x563/324912.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">dstrive</div><div class="author-info__description">个人博客，记录笔记</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dstrive06"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">重拾热爱...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">12.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%95%88%E7%8E%87%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">12.2 硬件的效率与一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">12.3 Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="toc-text">12.3.1 主内存与工作内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-text">12.3.2 内存间交互操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-3-%E5%AF%B9%E4%BA%8Evolatile%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="toc-text">12.3.3 对于volatile型变量的特殊规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%AD%A4%E5%8F%98%E9%87%8F%E5%AF%B9%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">保证此变量对所有线程的可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-text">禁止指令重排序优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-4-%E9%92%88%E5%AF%B9long%E5%92%8Cdouble%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="toc-text">12.3.4 针对long和double型变量的特殊规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-5-%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">12.3.5 原子性、可见性与有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89"><span class="toc-text">1.原子性（Atomicity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%88Visibility%EF%BC%89"><span class="toc-text">2.可见性（Visibility）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%88Ordering%EF%BC%89"><span class="toc-text">3.有序性（Ordering）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-6-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99"><span class="toc-text">12.3.6 先行发生原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-Java%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">12.4 Java与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">12.4.1 线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.内核线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.用户线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.混合实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.Java线程的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-2-Java%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">12.4.2 Java线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%90%8C%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">协同式调度的多线程系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">抢占式调度的多线程系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-3-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">12.4.3 状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-Java%E4%B8%8E%E5%8D%8F%E7%A8%8B"><span class="toc-text">12.5 Java与协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-1-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-text">12.5.1 内核线程的局限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-2-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%A4%8D%E8%8B%8F"><span class="toc-text">12.5.2 协程的复苏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-3-Java%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">12.5.3 Java的解决方案</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/blog/09209b9f0712/" title="Mybatis执行流程">Mybatis执行流程</a><time datetime="2022-05-18T13:25:33.000Z" title="发表于 2022-05-18 21:25:33">2022-05-18</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/blog/1f7ff14317f9/" title="第13章 线程安全与锁优化">第13章 线程安全与锁优化</a><time datetime="2022-05-18T12:58:12.000Z" title="发表于 2022-05-18 20:58:12">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/5b9a996050a2/" title="第12章 Java内存模型与线程"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第12章 Java内存模型与线程"/></a><div class="content"><a class="title" href="/blog/5b9a996050a2/" title="第12章 Java内存模型与线程">第12章 Java内存模型与线程</a><time datetime="2022-05-18T12:58:08.000Z" title="发表于 2022-05-18 20:58:08">2022-05-18</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/blog/8c72b87b40d9/" title="第11章 后端编译与优化">第11章 后端编译与优化</a><time datetime="2022-05-18T12:57:36.000Z" title="发表于 2022-05-18 20:57:36">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/1ee8bf0cee08/" title="第10章 前端编译与优化"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第10章 前端编译与优化"/></a><div class="content"><a class="title" href="/blog/1ee8bf0cee08/" title="第10章 前端编译与优化">第10章 前端编译与优化</a><time datetime="2022-05-18T00:22:06.000Z" title="发表于 2022-05-18 08:22:06">2022-05-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By dstrive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">hello，welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>